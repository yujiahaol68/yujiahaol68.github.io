<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DP on Runtime: out of memory</title>
    <link>/tags/dp/</link>
    <description>Recent content in DP on Runtime: out of memory</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 29 Jul 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>poj 3616 Milking Time</title>
      <link>/blog/poj-3616-milking-time/</link>
      <pubDate>Sun, 29 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-3616-milking-time/</guid>
      <description>原题地址 知识点：权值区间DP 解题报告 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; struct P { int start, end, e; }; bool cmp(const P &amp;amp;a, const P &amp;amp;b) { return a.start &amp;lt; b.start; } int N, M, R; struct P a[1002]; int dp[1002]; int main() { scanf(&amp;#34;%d %d %d&amp;#34;, &amp;amp;N, &amp;amp;M, &amp;amp;R); int i, j; for(i=0;i&amp;lt;M;i++) {</description>
    </item>
    
    <item>
      <title>poj 2385 Apple Catching 0ms</title>
      <link>/blog/poj-2385-apple-catching/</link>
      <pubDate>Sat, 14 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-2385-apple-catching/</guid>
      <description>原题地址 知识点：DP 解题报告 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; // j部分定义成 31 时不行？ 向前计算的时候有移动 0，..., 30次，共 31 个状态，因此要定义成 32 // d[第</description>
    </item>
    
    <item>
      <title>poj 2229 Sumsets</title>
      <link>/blog/poj-2229-sumsets/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-2229-sumsets/</guid>
      <description>原题地址 知识点：DP 解题报告 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;string.h&amp;gt; int sum; int d[1000001]; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;sum); int i; // 初始化唯一确定方案数，d[1] 为 1 表示 1 的分解方案只有 1 种 d[1] = 1; for(i=2;i&amp;lt;=sum;++i) { // 找规律，当 i</description>
    </item>
    
    <item>
      <title>poj 3176 Cow Bowling</title>
      <link>/blog/poj-3176-cow-bowling/</link>
      <pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-3176-cow-bowling/</guid>
      <description>原题地址 知识点：DP 解题报告 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace std; int a[350][350]; int d[350][350]; int N; int main() { scanf(&amp;#34;%d&amp;#34;, &amp;amp;N); int i, j; for(i=0;i&amp;lt;N;++i) { for(j=0;j&amp;lt;i+1;++j) { scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i][j]); } } d[0][0] = a[0][0]; for(i=0;i&amp;lt;N-1;++i) { for(j=0;j&amp;lt;=i;++j) { // 注意这里记忆计算让重叠路径的值最大的技</description>
    </item>
    
  </channel>
</rss>