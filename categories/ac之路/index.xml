<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AC之路 on Runtime: out of memory</title>
    <link>/categories/ac%E4%B9%8B%E8%B7%AF/</link>
    <description>Recent content in AC之路 on Runtime: out of memory</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 13 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/categories/ac%E4%B9%8B%E8%B7%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 985. Sum of Even Numbers After Queries</title>
      <link>/blog/leetcode-985.-sum-of-even-numbers-after-queries/</link>
      <pubDate>Wed, 13 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/blog/leetcode-985.-sum-of-even-numbers-after-queries/</guid>
      <description>题目描述 时间复杂度：O(N) 空间复杂度：O(1) // Author: Tecker // 176ms, 28.7MB; beat 96.40%, 100% class Solution { public: vector&amp;lt;int&amp;gt; sumEvenAfterQueries(vector&amp;lt;int&amp;gt;&amp;amp; A, vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;&amp;amp; queries) { vector&amp;lt;int&amp;gt; res(A.size(), 0); int sum=0; A[queries[0][1]]+=queries[0][0]; for(int &amp;amp;num : A) { if (num%2==0) sum+=num; } res[0]=sum; for(int i=1;i&amp;lt;queries.size();++i) { int val=queries[i][0]; int idx=queries[i][1]; int tmp =</description>
    </item>
    
    <item>
      <title>poj 3616 Milking Time</title>
      <link>/blog/poj-3616-milking-time/</link>
      <pubDate>Sun, 29 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-3616-milking-time/</guid>
      <description>原题地址 知识点：权值区间DP 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; struct P { int start, end, e; }; bool cmp(const P &amp;amp;a, const P &amp;amp;b) { return a.start &amp;lt; b.start; } int N, M, R; struct P a[1002]; int dp[1002]; int main() { scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;N, &amp;amp;M, &amp;amp;R); int i,</description>
    </item>
    
    <item>
      <title>poj 2385 Apple Catching 0ms</title>
      <link>/blog/poj-2385-apple-catching/</link>
      <pubDate>Sat, 14 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-2385-apple-catching/</guid>
      <description>原题地址 知识点：DP 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; // j部分定义成 31 时不行？ 向前计算的时候有移动 0，..., 30次，共 31 个状态，因此要定义成 32 // d</description>
    </item>
    
    <item>
      <title>poj 2229 Sumsets</title>
      <link>/blog/poj-2229-sumsets/</link>
      <pubDate>Thu, 12 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-2229-sumsets/</guid>
      <description>原题地址 知识点：DP 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;string.h&amp;gt; int sum; int d[1000001]; int main() { scanf(&amp;quot;%d&amp;quot;, &amp;amp;sum); int i; // 初始化唯一确定方案数，d[1] 为 1 表示 1 的分解方案只有 1 种 d[1] = 1; for(i=2;i&amp;lt;=sum;++i) { // 找规律，当</description>
    </item>
    
    <item>
      <title>Poj 3262 Protecting the Flowers</title>
      <link>/blog/poj-3262-protecting-the-flowers/</link>
      <pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-3262-protecting-the-flowers/</guid>
      <description>原题地址 知识点：贪心 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; using namespace std; struct P { int t, d; }; // 贪心使得代价最小 // cost = 2 * T * (total - D) // 因此 D越大，T越小越好 // 重点：转换成</description>
    </item>
    
    <item>
      <title>poj 3176 Cow Bowling</title>
      <link>/blog/poj-3176-cow-bowling/</link>
      <pubDate>Wed, 11 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-3176-cow-bowling/</guid>
      <description>原题地址 知识点：DP 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; int a[350][350]; int d[350][350]; int N; int main() { scanf(&amp;quot;%d&amp;quot;, &amp;amp;N); int i, j; for(i=0;i&amp;lt;N;++i) { for(j=0;j&amp;lt;i+1;++j) { scanf(&amp;quot;%d&amp;quot;, &amp;amp;a[i][j]); } } d[0][0] = a[0][0]; for(i=0;i&amp;lt;N-1;++i) { for(j=0;j&amp;lt;=i;++j) { // 注意这里记忆计算让重叠路径的值最大</description>
    </item>
    
    <item>
      <title>poj 1017 Packets</title>
      <link>/blog/poj-1017-packets/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-1017-packets/</guid>
      <description>知识点：贪心 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;algorithm&amp;gt; int square[7]; // 解法：每次都先放最大 int solve() { int res = 0; // 6x6 直接成一块 res += square[6]; // 5x5 先成一块，再补 1x1 res += square[5]; square[1] -= 11 * square[5]; // 4x4 先成一块，然</description>
    </item>
    
    <item>
      <title>poj 3040 Allowance</title>
      <link>/blog/poj-3040-allowance/</link>
      <pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-3040-allowance/</guid>
      <description>知识点： 贪心 解题报告 #include &amp;lt;cstdio&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;algorithm&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;limits&amp;gt; using namespace std; struct Coin { int d; int b; }; bool cmp(const Coin &amp;amp;a, const Coin &amp;amp;b) { return a.d &amp;gt; b.d; } vector&amp;lt;Coin&amp;gt; v; int N, C; int need_count[20]; int main() { scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;N, &amp;amp;C); int res = 0; for(int i=0;i&amp;lt;N;i++) { struct Coin c;</description>
    </item>
    
    <item>
      <title>poj 1979 Red and Black</title>
      <link>/blog/poj-1979-red-and-black/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/poj-1979-red-and-black/</guid>
      <description>知识点：DFS solution #include &amp;lt;cstdio&amp;gt; int W, H; char tile[25][25]; int pos_x, pos_y; int sh_x[4] = {0, 0, -1, 1}; int sh_y[4] = {1, -1, 0, 0}; int res = 0; void solve(int x, int y) { tile[y][x] = &#39;#&#39;; res++; for (int i=0;i&amp;lt;4;i++) { int new_x = x + sh_x[i]; int new_y = y + sh_y[i]; if (new_x &amp;gt;= 0 &amp;amp;&amp;amp; new_x &amp;lt;W &amp;amp;&amp;amp;</description>
    </item>
    
    <item>
      <title>AC之路 序</title>
      <link>/blog/ac%E4%B9%8B%E8%B7%AF-%E5%BA%8F/</link>
      <pubDate>Wed, 27 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>/blog/ac%E4%B9%8B%E8%B7%AF-%E5%BA%8F/</guid>
      <description>不知不觉就要到大三了，也玩过很多东西，但总感觉缺乏新的挑战，到达了一个瓶颈。 于是想要隐居深山，闭关修炼，回到计算机的本源，更多跟深地去死磕自</description>
    </item>
    
  </channel>
</rss>