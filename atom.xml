<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Refactor&#39;s Blog</title>
  
  <subtitle>Major in full stack especially node.js backend and share knowledge with everyone</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tecknight.xyz/"/>
  <updated>2017-11-01T11:21:08.000Z</updated>
  <id>http://tecknight.xyz/</id>
  
  <author>
    <name>Tecker.Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux必知之网络基础篇</title>
    <link href="http://tecknight.xyz/2017/10/31/Linux%E5%BF%85%E7%9F%A5%E4%B9%8B%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://tecknight.xyz/2017/10/31/Linux必知之网络基础篇/</id>
    <published>2017-10-31T14:33:23.000Z</published>
    <updated>2017-11-01T11:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本层次结构"><a href="#基本层次结构" class="headerlink" title="基本层次结构"></a>基本层次结构</h4><img src="/2017/10/31/Linux必知之网络基础篇/InternetLayers.png" alt="InternetLayers.png" title=""><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>当每个主机连接到一个子网的时候，其在子网中就会有一个IP地址，这个IP地址应该是唯一的但是在专用网络和NAT的情况中，<br>会有多个IP地址</p><p>查看地址：<code>ipconfig</code></p><p><strong>inet addr</strong>: IP地址</p><p><strong>Mask</strong>: 子网掩码，定义了IP地址的所属</p><p>将它们分别写成四个八位二进制数，每位进行对应，将IP中与掩码的1对应的位加粗，剩余未加粗的是可以变动的，从而可以发现子网之中IP的共用IP前缀</p><p>如：</p><pre><code>255.255.255.011111111 11111111 11111111 00000000子网内的IP的前三位都是相同的，很容易推出子网中其他的IP</code></pre><p><strong>路由表</strong></p><pre><code>$ route -n</code></pre><pre><code>Kernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Iface0.0.0.0         10.135.0.1      0.0.0.0         UG    0      0        0 eth010.135.0.0      0.0.0.0         255.255.192.0   U     0      0        0 eth0169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0</code></pre><p>0.0.0.0 是默认路由，能匹配互联网中的所有IP</p><p><strong>Destination</strong> 表示前缀</p><p><strong>Gateway</strong> 默认网关列，如果目标地址没有匹配其他网络，那就是将信息从默认网关中发出</p><p><strong>Flags</strong>的U表示该路由是可活动的可以直接访问，有G的表示需要通过Gateway才可以访问</p><h4 id="数据包追踪"><a href="#数据包追踪" class="headerlink" title="数据包追踪"></a>数据包追踪</h4><p>常用: <code>ping</code> <code>traceroute</code></p><p><strong>ping</strong>用于检测是否有丢包和是否能快速响应</p><p><strong>traceroute</strong>能显示数据包到目标主机所经过的路由</p><h4 id="host-和-DNS"><a href="#host-和-DNS" class="headerlink" title="host 和 DNS"></a>host 和 DNS</h4><p>使用 <code>host</code>+域名的命令可以使用系统自带的DNS库找到域名的IP</p><p>过程如下：</p><ol><li>查询函数位于系统共享库</li><li>根据规则查找，一般是先检查 <code>/etc/hosts</code> 文件中的重写（解释了localhost）</li><li>若没有，守护进程（常见是dnsmasq和nscd）会对DNS查询请求进行拦截，如果命中缓存，则返回</li><li>如还没有，则会找到配置好的DNS服务器IP，发送查询请求</li><li>DNS服务器收到后返回域名对应的IP给应用</li></ol><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>基本概念</p><ul><li>MAC硬件地址（介质访问控制）</li><li>以太网以<strong>帧</strong>的形式发送信息，帧里除了实际数据还有发送者和接受者的MAC地址</li><li>以太网会有不同的类型，那么在网络层的路由器会将其先解包，然后再重新封装发给目标</li><li>内核的网络接口沟通了物理层和网络层，这个接口将IP地址和硬件标识对应起来</li></ul><p>查看或配置网络接口</p><pre><code>$ ifconfig</code></pre><p>输出的左面是接口名称，右边是配置以及统计信息</p><p><strong>eth0</strong>: 计算机第一块以太网网卡</p><p><strong>lo</strong>: 虚拟的网络接口，全名<code>loopback</code>，指向自己，数据发送到lo时内核只会将其重新包装，并通过lo回复</p><h4 id="网络配置管理器"><a href="#网络配置管理器" class="headerlink" title="网络配置管理器"></a>网络配置管理器</h4><p>守护进程 <strong>NetworkManager</strong> 维护网络和连接的信息和配置，在图形界面中的桌面网络连接设置其实就是与这个进程来交互的</p><h4 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP 动态主机配置协议"></a>DHCP 动态主机配置协议</h4><p>用过校园网的朋友们应该都十分清楚，每次都需要登录客户端进行验证，然后就能够动态地获取到IP，DNS，子网掩码等相关的网络配置，<br>通常路由器承担了DHCP服务器的角色，其管理和分配其下的连接主机的网络配置，这样就避免了IP冲突或网络变更所带来的影响，主机只向DHCP服务器临时租用IP，<br>到期之后DHCP服务器可以要求更新配置</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层的协议使得网络层的包与应用层的需求无缝连接，其中包含有TCP和UDP协议</p><p>查看机器上的连接</p><pre><code>$ netstat -nt</code></pre><p>建立本地和远端机器的TCP连接，本机进程会使用一个端口向远端的公共端口（通常是80）发送一些特殊的数据包，这个过程是我们所熟知的TCP握手连接，这里不进行详细展开，<br>在远端的机器也会启动一个进程来监听这个公共端口，监听方就被成为服务器</p><p>而UDP则简单得多，它默认本机与服务器是通路，不会进行校验，直接发送</p><p>查看公认端口的数字: <code>/etc/services</code></p><p>好处：使得进程处理发送和接收更加容易，就像处理文件的输出流和输入流那样，同时这一层也做到了包与数据流之间的转换和包的数据校验纠正工作</p><h4 id="IP伪装"><a href="#IP伪装" class="headerlink" title="IP伪装"></a>IP伪装</h4><p>使用<strong>NAT</strong>将IP分享给整个私有网络，使得路由器可以作为中介去访问远程主机而远程却只知道它与路由器建立了连接</p><p>大致过程如下：</p><ol><li>私有网络里的主机要与外界通信，请求会经过路由器</li><li>路由器拦截请求，然后自身启动请求去连接目标</li><li>连接成功后伪造连接已建立的信息返回给网络里的主机然后作为本机和远程的中介</li></ol><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><p>可以在下面的几个场景下设置检查点：</p><ul><li>接收数据包时</li><li>发送数据包时</li><li>将数据包转发到其他主机或网关时</li></ul><p>防火墙的策略配置：详情见 <code>iptables</code></p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>服务器并不区分发给操作系统的报头和内容，区分只发生于用户空间的服务器程序</p><p>多数的网络服务器都是多进程的，至少有一个进程会监听网络端口，接收到一个新的连接时就<strong>fork()</strong>一个新的子进程来处理连接，<br>个别的高性能服务器会提前<strong>fork()</strong>出辅助进程的来高效处理连接，连接终止，子进程也就终止</p><p>这里列举一些常用的诊断命令：</p><ul><li>netstat</li><li>lsof</li><li>tcpdump</li></ul><p><strong>RPC（远程程序调用）</strong>：通过本地程序调用远程程序（使用程序标识符来区分），让远程返回结果或信息，有些监控系统会用到</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本层次结构&quot;&gt;&lt;a href=&quot;#基本层次结构&quot; class=&quot;headerlink&quot; title=&quot;基本层次结构&quot;&gt;&lt;/a&gt;基本层次结构&lt;/h4&gt;&lt;img src=&quot;/2017/10/31/Linux必知之网络基础篇/InternetLayers.png&quot; a
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="运维" scheme="http://tecknight.xyz/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux日常之进程内存篇</title>
    <link href="http://tecknight.xyz/2017/10/31/Linux%E6%97%A5%E5%B8%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E7%AF%87/"/>
    <id>http://tecknight.xyz/2017/10/31/Linux日常之进程内存篇/</id>
    <published>2017-10-31T04:23:14.000Z</published>
    <updated>2017-10-31T11:18:27.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>内核</strong>：运行于硬件之上，是操作系统的核心，运行于内存中</p><p><strong>进程</strong>：计算机中运行的所有程序，并由内核统一管理，这些进程组成了用户空间</p><p><strong>用户进程</strong>：如图形界面的进程，服务器进程，命令行进程这类用户层级的进程</p><p>内核在内核模式中运行，能直接访问处理器和内存，不能容错；而用户进程运行于用户模式中，一个进程崩溃不会影响整个系统的运行</p><p><strong>线程</strong>：比进程更加细粒度的概念，一般所提到的进程都是单线程，多线程的进程的启动会比多进程要更快，主线程会类似<code>fork</code>出来其他的子线程，<br>而且可以方便地相互通信以及共享IO和系统资源</p><h4 id="内核对进程和内存的管理"><a href="#内核对进程和内存的管理" class="headerlink" title="内核对进程和内存的管理"></a>内核对进程和内存的管理</h4><ul><li>进程：内核决定哪一个进程可以使用CPU</li><li>内存：内核管理所有内存，为进程分配内存，包括进程间的共享内存以及空闲内存</li></ul><h4 id="理解内核对进程的管理"><a href="#理解内核对进程的管理" class="headerlink" title="理解内核对进程的管理"></a>理解内核对进程的管理</h4><p>对单核CPU来说，每一个进程都是轮流使用CPU，CPU会对每一个到来的进程计时，到时即暂停，接着切换至内核模式，内核会记录下CPU和内存的状态，<br>用于恢复被停止的进程，内核执行上一时间段的任务如磁盘读写，然后选择已就绪的进程来执行，内核为新进程准备CPU和内存（也可以是为了之前暂停的进程），<br>内核将时间段告诉CPU，内核将CPU切换回用户模式，然后进程继续使用CPU进行计算</p><p>CPU的使用权在进程之间切换的过程叫做<strong>上下文切换</strong>，内核运行于上下文切换的间隙时间中</p><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><strong>fork()</strong>: 内核创建进程副本</p><p><strong>exec()</strong>： 内核使用<code>exec(program)</code>中的program来替换当前的进程</p><p>需要内核帮忙的进程都使用先<code>fork</code>然后<code>exec(..)</code>的方式来请求内核</p><h4 id="进程的追踪"><a href="#进程的追踪" class="headerlink" title="进程的追踪"></a>进程的追踪</h4><p>常用命令： </p><p>进程信息：<code>top</code>和 <code>ps</code></p><p>进程与文件的信息： <code>lsof</code></p><p>追踪系统调用： <code>strace</code></p><p>追踪共享库调用： <code>ltrace</code></p><h4 id="追踪线程"><a href="#追踪线程" class="headerlink" title="追踪线程"></a>追踪线程</h4><pre><code>$ ps m</code></pre><p>或者 <code>top</code> 下按 <code>H</code></p><h4 id="测量CPU时间"><a href="#测量CPU时间" class="headerlink" title="测量CPU时间"></a>测量CPU时间</h4><pre><code>$ top -p pid1</code></pre><p>命令文件执行CPU计时</p><pre><code>$ /usr/bin/time command</code></pre><h4 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h4><pre><code>$ uptime</code></pre><p>表明CPU的繁忙程度，通常web服务器的平均负载较高，进程的启动快，结束也快</p><p>平均负载高但是响应慢的话通常是内存性能受到较大的影响，内存不足时会有很多的进程在准备状态，但是没有足够的内存供要执行的进程使用</p><p>内存的状态可以使用： <code>free</code> 命令查看</p><h4 id="理解CPU，内核与内存的关系"><a href="#理解CPU，内核与内存的关系" class="headerlink" title="理解CPU，内核与内存的关系"></a>理解CPU，内核与内存的关系</h4><p>CPU通过MMU（内存管理单元）将进程访问的虚拟地址转换为实际的内存地址，内核辅助MMU将进程使用的内存划分为更小的区域，成为页面，多个页面使用<br>页面表（内核维护的一个数据结构）进行管理，MMU可以通过这个页面表将虚拟地址映射到实际的内存地址，页面的分配是按需分配，按需的过程大致是开始时指令会被加载到<br>页面，如果这个进程的下一个指令被执行的时候之前已加载的内存页面不存在，那么内核就会加载指令需要的内存页面，再让程序恢复执行，如果进程需要更多的内存，也同样需要<br>内核先去获得更多的内存然后再进行分配</p><h4 id="内存页面中的错误"><a href="#内存页面中的错误" class="headerlink" title="内存页面中的错误"></a>内存页面中的错误</h4><ul><li>轻微内存页面错误：如果需要的内存页面在主内存中但是MMU无法找到，通常是进程想要更多的内存但是MMU中的空间有限时发生</li><li>严重内存页面错误：如果需要的页面在主内存中不存在的话，那么内核就会尝试从磁盘等存储媒介中加载，多数的错误会影响系统性能，在第一次从磁盘中加载代码或者<br>是内存不足时极可能出现</li></ul><p>查看方式：</p><pre><code>$ /usr/bin/time</code></pre><h4 id="对CPU和内存进行监控"><a href="#对CPU和内存进行监控" class="headerlink" title="对CPU和内存进行监控"></a>对CPU和内存进行监控</h4><pre><code>$ vmstat n // 每n秒刷新一次数据</code></pre><h4 id="IO监控"><a href="#IO监控" class="headerlink" title="IO监控"></a>IO监控</h4><ul><li>全局</li></ul><pre><code>$ iostat</code></pre><ul><li>对进程</li></ul><pre><code>$ iotop</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;内核&lt;/strong&gt;：运行于硬件之上，是操作系统的核心，运行于内存中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="运维" scheme="http://tecknight.xyz/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux日常之cron篇</title>
    <link href="http://tecknight.xyz/2017/10/30/Linux%E6%97%A5%E5%B8%B8%E4%B9%8Bcron%E7%AF%87/"/>
    <id>http://tecknight.xyz/2017/10/30/Linux日常之cron篇/</id>
    <published>2017-10-30T12:04:37.000Z</published>
    <updated>2017-10-30T12:42:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>cron 能够让我们创建 linux 的定时任务，是系统的内置服务，通过加入自己的配置来达到在某时间段重复执行任务的目的</p><h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>通过执行这个命令，我们可以将我们的 <code>crontab</code> 文件装载到 <code>/var/spool/cron/crontabs</code> 中</p><p>文件内格式:</p><p><code>13 04 * * * Command</code></p><p>最开始的五列从左到右依次为分，时，天，月，星期，星号表示每个</p><p>分隔符：</p><p><code>,</code> 表示分隔时间点，如： <code>00 10,12 * * *</code> 的意思是每天的10点和12点</p><p><code>-</code> 表示时间段，又如： <code>00 10-12 * * *</code> 的意思是每天10点到12点的每个整点时刻</p><p><code>\n</code> 表示每隔n单位的时间，如： <code>*/5 * * * *</code> 的意思是每隔5分钟 </p><p><strong>值得注意的是要运行的执行文件需要使用全局路径</strong></p><p>例如：<br><code>13 04 * * * /etc/init.d/smb restart</code></p><p>常用参数</p><pre><code>$ crontab -l // 列出任务$ crontab -r name // 删除任务文件$ crontab -e // 更改并安装任务文件，进入编辑区，编辑完成保存退出即成功</code></pre><p>如果是某一时刻一次性的任务调度可以使用 <code>at</code> 命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cron 能够让我们创建 linux 的定时任务，是系统的内置服务，通过加入自己的配置来达到在某时间段重复执行任务的目的&lt;/p&gt;
&lt;h2 id=&quot;crontab&quot;&gt;&lt;a href=&quot;#crontab&quot; class=&quot;headerlink&quot; title=&quot;crontab&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="运维" scheme="http://tecknight.xyz/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>一文讲透koa-源码剖析</title>
    <link href="http://tecknight.xyz/2017/10/17/%E4%B8%80%E6%96%87%E8%AE%B2%E9%80%8Fkoa-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://tecknight.xyz/2017/10/17/一文讲透koa-源码剖析/</id>
    <published>2017-10-17T14:59:20.000Z</published>
    <updated>2017-10-18T12:17:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文从头开始由浅入深剖析现在十分流行的koa框架的核心源码，适合已经熟练掌握koa框架使用的开发人员阅读</p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><p>现在，让我们从头开始看看koa的内部究竟做了些什么？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// usage</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Koa</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>proxy <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>middleware <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subdomainOffset <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>env <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>NODE_ENV <span class="token operator">||</span> <span class="token string">'development'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这就是一切的起源，<code>Koa</code> 类的实例从此诞生，继承自 <code>Events</code>，可得知其子类拥有处理异步事件的能力，然而<code>Koa</code>如何处理，现在还不得而知，先打个问号。但创建实例的过程中，可得知有三个对象作为实例的属性被初始化，分别为 <code>context</code> <code>request</code> <code>response</code>，还有我们非常熟悉的存放所有全局中间件的数组<code>middleware</code></p><h4 id="koa-class-图示"><a href="#koa-class-图示" class="headerlink" title="koa class 图示"></a>koa class 图示</h4><img src="/2017/10/17/一文讲透koa-源码剖析/koa.png" alt="koa.png" title=""><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// usage </span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中间件函数</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当调用use方法时，在确认它是<code>async</code>函数的情况下，通过<code>push</code>操作，这个函数会被追加到<code>middleware</code>数组中</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">use</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 类型检查...</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>此时我们已经有了处理的操作，但是<code>koa</code>还并没有真正的跑起来</p><pre class=" language-javascript"><code class="language-javascript">app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以说当开启<code>http</code>服务器的时候，<code>koa</code>才真正能够开始处理我们的<code>http</code>请求，那么这样一个简洁的调用背后具体究竟做了什么呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>koa</code> 使用了 <code>node</code> 的原生 <code>http</code>包来创建<code>http服务</code>,所有的秘密都藏匿在 <code>callback()</code> 这个方法中</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>middleware<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">...</span><span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>koa</code> 自身还依赖于 <code>koa-compose</code> 模块，从 <code>koa</code>对于 <code>fn</code> 的使用情况来看，<code>middleware</code> 应该是被封装成了一个叫做 <code>fn</code> 的对象，通过传入 <code>context</code> 对象来返回一个 <code>Promise</code></p><p>现在，深入 <code>koa-compose</code> 模块来看看它又对我们的中间件数组做了什么。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>context<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// last called middleware #</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>  <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>  <span class="token keyword">function</span> dispatch <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> index<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'next() called multiple times'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    index <span class="token operator">=</span> i    <span class="token keyword">let</span> fn <span class="token operator">=</span> middleware<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> middleware<span class="token punctuation">.</span>length<span class="token punctuation">)</span> fn <span class="token operator">=</span> next    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 递归结束</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token keyword">function</span> next <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 递归调用dispatch</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>里面的闭包看起来很眼熟是吗？再对比一下</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// usage </span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 中间件函数</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里的 <code>Promise.resolve(fn(..))</code> 帮助我们异步执行的中间件函数，这里的<code>next</code>函数就解释了为什么<code>Koa</code>的中间件调用是递归执行的，它递归调用了 <code>dispatch</code> 函数来遍历数组中的，同时，所有的中间件函数享有同一个 <code>ctx</code>，再回顾一次外部</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> handleRequest <span class="token operator">=</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createContext</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> ctx<span class="token punctuation">.</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> handleResponse <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">respond</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">onFinished</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> onerror<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">return</span> handleRequest<span class="token punctuation">;</span></code></pre><p><code>context</code> 使用node原生的 <code>http</code> 的监听回调函数中的 <code>req</code> <code>res</code> 来进行进一步的封装，意味着对于每一个 <code>http</code> 请求，<code>koa</code>都会创建一个 <code>context</code> 并共享给所有的全局中间件使用，当所有的中间件执行完过后，会将最后要返回的所有数据统一再交还给 <code>res</code> 进行返回，所以我们在每一个中间件中才能够从 <code>ctx</code> 中取得自己所需要的 <code>req</code> 中的数据进行处理，最后 <code>ctx</code> 再把要返回的 <code>body</code> 给原生的 <code>res</code> 进行返回</p><p>每一个请求都有唯一一个 <code>context</code> 对象，所有的关于请求和返回的东西都统一放在里面</p><p><code>createContext</code> 方法将 <code>req</code> <code>res</code> 进一步封装</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token keyword">const</span> context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建一个对象，使之拥有context的原型方法，后面以此类推</span><span class="token keyword">const</span> request <span class="token operator">=</span> context<span class="token punctuation">.</span>request <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> response <span class="token operator">=</span> context<span class="token punctuation">.</span>response <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span>app <span class="token operator">=</span> request<span class="token punctuation">.</span>app <span class="token operator">=</span> response<span class="token punctuation">.</span>app <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span>req <span class="token operator">=</span> request<span class="token punctuation">.</span>req <span class="token operator">=</span> response<span class="token punctuation">.</span>req <span class="token operator">=</span> req<span class="token punctuation">;</span>context<span class="token punctuation">.</span>res <span class="token operator">=</span> request<span class="token punctuation">.</span>res <span class="token operator">=</span> response<span class="token punctuation">.</span>res <span class="token operator">=</span> res<span class="token punctuation">;</span>request<span class="token punctuation">.</span>ctx <span class="token operator">=</span> response<span class="token punctuation">.</span>ctx <span class="token operator">=</span> context<span class="token punctuation">;</span>request<span class="token punctuation">.</span>response <span class="token operator">=</span> response<span class="token punctuation">;</span>response<span class="token punctuation">.</span>request <span class="token operator">=</span> request<span class="token punctuation">;</span></code></pre><p>本着一个请求一个<code>context</code>的原则，<code>context</code> 必须是作为一个临时对象而存在，所有的东西都必须封进一个对象中，因此 <code>app</code> <code>req</code> <code>res</code> 三个属性就此诞生，但不知道大家是否有一个疑问，为什么 <code>app</code> <code>req</code> <code>res</code> 也同时被封在了 <code>request</code> 和 <code>response</code> 里 ？</p><p>使他们同时共享同一个 <code>app</code> <code>req</code> <code>res</code> 和 <code>ctx</code>，是为了将处理职责进行转移，客户从外部访问，他们只需要一个 <code>ctx</code> 即可获得所有 <code>koa</code> 提供的数据和方法，而 <code>koa</code> 会继续将这些职责进行进一步的划分，比如 <code>request</code> 是用来进一步封装 <code>req</code> 的，<code>response</code> 是用来进一步封装 <code>res</code>的，这样职责得到了分散，降低了耦合，同时共享所有资源使得整个 <code>context</code> 具有了高内聚的性质，内部元素互相都能够访问得到</p><pre><code>// source codecontext.state = {};</code></pre><p>看得出来，其中的 <code>state</code> 就是专门负责保存单个请求状态的空对象，用户可以根据自己的需要来管理里面的内容</p><pre><code>// source codeconst ctx = this.createContext(req, res);const onerror = err =&gt; ctx.onerror(err);</code></pre><p>这个巨大的 <code>ctx</code> 被创建出来的时候在一开始就立马挂载了错误监听器，但在 <code>createContext</code> 中并没有发现这个<code>onerror</code>方法，应该属于其中一个模块的原型方法，经过一番搜索，发现它位于 <code>context.js</code> 这个文件下，这个文件定义了所有的默认 <code>context</code> 对象具有的原型方法</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// application.js</span><span class="token comment" spellcheck="true">// handleRequest()</span><span class="token keyword">const</span> onerror <span class="token operator">=</span> err <span class="token operator">=</span><span class="token operator">></span> ctx<span class="token punctuation">.</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">onFinished</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> onerror<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>handleResponse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>onerror<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>异步函数运行过程中如果有异常抛出且内部没有自行捕获异常的话， <code>koa</code> 会统一使用 <code>Promise</code> 的<code>catch</code> 语句来进行错误处理，用一个图来表示的话那就是这样</p><h4 id="koa-请求处理流程图"><a href="#koa-请求处理流程图" class="headerlink" title="koa 请求处理流程图"></a>koa 请求处理流程图</h4><img src="/2017/10/17/一文讲透koa-源码剖析/koa-request-process.png" alt="koa-request-process.png" title=""><p>到这里我们应该也不难解开本文开头时我们心中的一个疑问，那就是为什么要继承 <code>Events</code>，其实就是为了使用 <code>node</code> 自带的事件监听器来监听一些事件，例如目前所知的 <code>error</code> ，来解耦错误处理这一块的功能</p><p>全局的错误处理函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// source code</span><span class="token comment" spellcheck="true">// application.js</span><span class="token function">onerror</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">assert</span><span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token string">`non-error thrown: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>err<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">404</span> <span class="token operator">==</span> err<span class="token punctuation">.</span>status <span class="token operator">||</span> err<span class="token punctuation">.</span>expose<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>silent<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">const</span> msg <span class="token operator">=</span> err<span class="token punctuation">.</span>stack <span class="token operator">||</span> err<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/^/gm</span><span class="token punctuation">,</span> <span class="token string">'  '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Koa</code> 的内部核心处理流程已经梳理完毕，现在我们再进入内部模块一探究竟</p><h3 id="request-模块"><a href="#request-模块" class="headerlink" title="request 模块"></a>request 模块</h3><p>大量的 <code>getter</code> <code>setter</code> 充分提取出 <code>node</code> <code>http</code> 所提供的有用的请求相关的属性，还有一些必要的 <code>helper</code> 函数这里不再赘述，API文档中几乎所有的 <code>ctx.req</code> 下的属性都在其下提供，值得一提的是其中的 <code>this</code> ，头疼的 <code>this</code> , 这一块的代码用了大量的 <code>this.req</code> 的方式来访问node原生提供的 http 请求信息(因为我们把 node 的<code>req</code>赋给了<code>context</code>)，当在 <code>koa</code> 外部进行使用时我们是通过 <code>ctx.req.propertyName</code> 的形式 … 没错，我想你也发现了，我们需要绑定我们的 <code>this</code> 使之指向的是 <code>ctx.req</code>，所以在 <code>context.js</code> 模块中使用了代理来将 <code>this</code> 进行正确的绑定，前文提到的使这些模块能够相互访问的赋值代码其实也一定程度减少了<code>this</code>的麻烦事</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 详见 delegates 包</span><span class="token comment" spellcheck="true">// https://github.com/tj/node-delegates</span><span class="token comment" spellcheck="true">// Koa context.js</span><span class="token function">delegate</span><span class="token punctuation">(</span>proto<span class="token punctuation">,</span> <span class="token string">'request'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'acceptsLanguages'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'acceptsEncodings'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'query'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">access</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">getter</span><span class="token punctuation">(</span><span class="token string">'origin'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// delegates 的内部核心实现，通过apply来重新绑定this</span>proto<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="response-模块"><a href="#response-模块" class="headerlink" title="response 模块"></a>response 模块</h3><p><code>response.js</code> 的内部也同 <code>request.js</code> 中类似，值得一提的是 <code>writable</code> 这个getter，如果请求已经得到相应，那么返回 <code>true</code>，其中读取的值是 <code>this.res.finished</code>，许多的报错中我们常常会碰到关于尝试重复写入响应头 <code>header</code> 的错误，这个错误的来源即使是 <code>on-finished</code> 这个包，当结束响应的时候此包能够执行一个回调来保存此请求的状态于 <code>res</code></p><h3 id="response-helper-函数"><a href="#response-helper-函数" class="headerlink" title="response helper 函数"></a>response helper 函数</h3><p>koa有一个统一的响应函数位于 <code>application.js</code> 的末尾，专门负责处理 <code>ctx.body</code> <code>ctx.status</code> 来进行请求响应</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// responses</span><span class="token keyword">if</span> <span class="token punctuation">(</span>Buffer<span class="token punctuation">.</span><span class="token function">isBuffer</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'string'</span> <span class="token operator">==</span> <span class="token keyword">typeof</span> body<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>body <span class="token keyword">instanceof</span> <span class="token class-name">Stream</span><span class="token punctuation">)</span> <span class="token keyword">return</span> body<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// body: json</span>body <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span>headersSent<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ctx<span class="token punctuation">.</span>length <span class="token operator">=</span> Buffer<span class="token punctuation">.</span><span class="token function">byteLength</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>值得注意的是返回的body支持 <code>Buffer</code> <code>string</code> 流，以及最常见的 <code>json</code></p><h4 id="全文完"><a href="#全文完" class="headerlink" title="全文完"></a>全文完</h4><p><strong>商业转载请联系作者获得授权，非商业转载请注明出处，谢谢合作！</strong></p><p>联系方式：tecker_yuknigh@163.com</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文从头开始由浅入深剖析现在十分流行的koa框架的核心源码，适合已经熟练掌握koa框架使用的开发人员阅读&lt;/p&gt;
&lt;h3 id=&quot;核心机制&quot;
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="源码分析" scheme="http://tecknight.xyz/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="koa" scheme="http://tecknight.xyz/tags/koa/"/>
    
  </entry>
  
  <entry>
    <title>常见设计模式概要及其实践-TypeScript实现</title>
    <link href="http://tecknight.xyz/2017/10/15/%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A6%81%E5%8F%8A%E5%85%B6%E5%AE%9E%E8%B7%B5-TypeScript%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tecknight.xyz/2017/10/15/常见设计模式概要及其实践-TypeScript实现/</id>
    <published>2017-10-15T02:29:16.000Z</published>
    <updated>2017-10-15T04:42:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>若有不足或纰漏，欢迎指教</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>得益于TypeScript强大灵活的OOP语法，使得在js中使用经典且可靠的OOP设计模式变成了现实，虽然有的公司已经在大规模地使用TS进行中大型项目的开发，但极少有项目真正充分发挥了TS健全的OO语法优势，Java like 的OOP语法使其在思想上与Java的设计模式几乎无异，本文选取了一些常见且重要的设计模式进行提炼总结，避免探讨OOP与函数式编程孰优孰劣，模式的具体实现均采用TS进行编写，文末有彩蛋哦。</p><p>本文所有实战代码示例的<a href="https://github.com/yujiahaol68/design-pattern-learning-ts" target="_blank" rel="external">GitHub仓库地址</a>，欢迎Star</p><p>使用设计模式的意义：库与框架无法帮助我们将应用组织成容易了解，容易维护，具有弹性的架构，所以需要设计模式</p><h3 id="基本设计原则："><a href="#基本设计原则：" class="headerlink" title="基本设计原则："></a>基本设计原则：</h3><ul><li>封装变化</li><li>多用组合，少用继承</li><li>想到系统以后可能需要的变化以及应付变化的原则</li><li>针对接口编程，不针对实现编程</li><li>为了交互对象之间的松耦合设计而努力</li><li>松耦合的目的在于把对象依赖降到最低，增强系统的弹性</li><li>类应该对扩展开放，对修改关闭（开闭原则）</li><li>依赖抽象，不要依赖具体类</li><li>依赖反转原则：变量不可以持有具体类的引用，不要让类派生自具体类，不要覆盖基类中已实现的方法（子类应共享），不大会改变的对象可以违反，变化的对象可以使用工厂封装变化</li><li>最少知识原则：设计过程中不要让过多的类耦合在一起，使得尽可能少的类在一起交互</li><li>对象方法内只应调用对象本身的方法，或参数传进来对象的方法，或此方法创建的任何对象，或对象内的组件的方法（如果调用其它方法返回的是对象，不要调用其方法）</li><li>采用原则之前应全盘考虑所有因素</li><li>高层组件可以自行决定何时让低层组件参与，但低层组件不可以直接调用高层组件（在一些情况下也可以但绝不能形成环形依赖）</li><li>一个职责只指派给一个类，当它被设计成支持一组相关功能时，就具有了高内聚</li><li>上述所有的原则并非工程中的金科玉律，实际情况需要我们不断地平衡和取舍</li></ul><h3 id="策略模式-Strategy-pattern"><a href="#策略模式-Strategy-pattern" class="headerlink" title="策略模式 Strategy pattern"></a>策略模式 Strategy pattern</h3><p>核心步骤是把类1中多变的不同种行为委托封装进一个个的行为类中，行为类1.2.3..将实现各自的同一接口的不同变种并以属性的形式存在于各个类1的相似类中，使算法变化独立于使用算法的客户</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>可以随时扩充新的行为</li><li>同一个类可以通过setter动态地改变它的行为</li></ol><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/strategy/main.ts" target="_blank" rel="external">Strategy</a></p><h3 id="观察者模式-Observer-pattern"><a href="#观察者模式-Observer-pattern" class="headerlink" title="观察者模式 Observer pattern"></a>观察者模式 Observer pattern</h3><p>用于更好描述对象之间一对多的关系，当多个对象（观察者）依赖于一个对象（主题）的状态变化时，观察者模式可以帮助我们进行状态分发，将更新发送到各个观察者中，并使这两者松耦合</p><h4 id="核心步骤："><a href="#核心步骤：" class="headerlink" title="核心步骤："></a>核心步骤：</h4><p>主题类实现Observable接口，类中实现了对观察者的管理和对是否推送数据的判断，观察者类实现Observer接口，实现其中包含update方法供主题类调用，当注册新的观察者时，主题对象会将观察者对象存在观察者数组中，推送数据时遍历数组调用update方法，将数据传入其观察者对象中</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/observer/main.ts" target="_blank" rel="external">Observer</a></p><h3 id="装饰者模式-Decorator-pattern"><a href="#装饰者模式-Decorator-pattern" class="headerlink" title="装饰者模式 Decorator pattern"></a>装饰者模式 Decorator pattern</h3><p>动态的赋予已有对象新的职责，比继承更具弹性，其中有使用到继承，但只是利用继承来达到类型匹配超类而不获得行为，行为来自于装饰者和基础组件或与其它装饰者的组合。</p><p>作为设计模式届的多米诺，每个新的被装饰者都不仅包含着上一个装饰者的状态而且还可以扩展自己的属性，通过共同的超类使得状态的共性得以保存且能够进行向上层级的链式调用，可以近似看做子类递归调用父类，使用此模式可以很好的替代继承</p><h4 id="核心步骤：-1"><a href="#核心步骤：-1" class="headerlink" title="核心步骤："></a>核心步骤：</h4><p>被装饰类统一派生自一个超抽象类A获得其类型，装饰抽象类B继承A，并在构造函数中保存A类型的对象的所有状态，每一个新的装饰者包装上一次的被装饰者，被装饰类在被装饰之后仍可不断地被扩展</p><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>客户代码不能依赖特殊类型，会出现许多小对象，过度使用会导致程序复杂</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/decorator/main.ts" target="_blank" rel="external">Decorator</a></p><h3 id="工厂模式-Factory-pattern"><a href="#工厂模式-Factory-pattern" class="headerlink" title="工厂模式 Factory pattern"></a>工厂模式 Factory pattern</h3><p>制造对象和解决耦合的好办法，严格来讲这并非一种模式而是一种编码习惯，将派生类的实例化封装在工厂类的静态方法中，抽象工厂方法可以让子类自行决定制造方式，在外部我们调用的抽象方法具有很大的弹性，实现可以不用绑定具体的类，这就得到了另外一个好处：使得超类和子类对象的代码解耦。而且能够将实例化延迟至子类中进行</p><h4 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h4><p>对需要弹性的方法使用抽象工厂方法来替代，想要使得产品可定制，可以将产品类定义成抽象类并提供一些默认的属性和方法或抽象方法，派生类可以自行进行覆盖重写或自行实现，不同的工厂类可以隐藏不同的产品的制造细节但却保留着相同的制作流程</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/factory/simple.ts" target="_blank" rel="external">Simple Factory</a></p><h4 id="抽象工厂-Abstract-Factory"><a href="#抽象工厂-Abstract-Factory" class="headerlink" title="抽象工厂 Abstract Factory"></a>抽象工厂 Abstract Factory</h4><p>不同的工厂类实现同一抽象工厂接口制造相似的产品，相似的产品再依赖于产品共同的接口来使得客户无须关心实际产出的具体产品就能使用</p><p>二者区别在于工厂方法委托子类来实例化对象，而抽象工厂建立了产品与客户的接口契约，两者都可以把客户从具体产品中解耦出来</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/factory/abstract.ts" target="_blank" rel="external">Abstract Factory</a></p><h3 id="单例模式-Singleton-pattern"><a href="#单例模式-Singleton-pattern" class="headerlink" title="单例模式 Singleton pattern"></a>单例模式 Singleton pattern</h3><p>实例化唯一一个对象，提供一个全局访问点，所有设计模式中最简单但非常实用且用途广泛</p><h4 id="核心要点："><a href="#核心要点：" class="headerlink" title="核心要点："></a>核心要点：</h4><p>把一个静态私有变量确立为唯一的实例，外部通过静态方法访问这个唯一的实例，并把构造函数设为私有</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/singleton/main.ts" target="_blank" rel="external">Singleton</a></p><h3 id="命令模式-Command-pattern"><a href="#命令模式-Command-pattern" class="headerlink" title="命令模式 Command pattern"></a>命令模式 Command pattern</h3><p>封装请求引入中间代理对象，将动作的请求者从动作的执行者中解耦出来，常用于工作队列或大型数据结构的操作记录以及事务处理</p><h4 id="核心步骤：-2"><a href="#核心步骤：-2" class="headerlink" title="核心步骤："></a>核心步骤：</h4><p>具体任务执行细节封装于Command接口的execute方法的实现中，然后将实现接口的类的实例传递给它的客户，再由客户通过调用其execute方法来执行</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/command/main.ts" target="_blank" rel="external">Command</a></p><h3 id="适配器模式-Adapter-pattern"><a href="#适配器模式-Adapter-pattern" class="headerlink" title="适配器模式 Adapter pattern"></a>适配器模式 Adapter pattern</h3><p>包装某些接口以实现不同的目的，转换接口使其能被其他的对象使用，改变接口符合客户的期望</p><h4 id="核心要点：-1"><a href="#核心要点：-1" class="headerlink" title="核心要点："></a>核心要点：</h4><p>对象适配器类实现目标接口并在其中调用待适配的对象的对应方法，使得在客户代码不变的前提下可以调用不同接口的对象</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/adapter/main.ts" target="_blank" rel="external">Adapter</a></p><h3 id="外观模式-Facade-pattern"><a href="#外观模式-Facade-pattern" class="headerlink" title="外观模式 Facade pattern"></a>外观模式 Facade pattern</h3><p>使用外观类Facade简化接口，封装复杂的子系统，并暴露出更少的更简单的接口，打造更高层的功能，针对外观编程可以使得客户与子系统的组件解耦</p><h4 id="核心要点：-2"><a href="#核心要点：-2" class="headerlink" title="核心要点："></a>核心要点：</h4><p>构造Facade类的时候集合子系统的各个组件对象，暴露出的接口提供更直接更高层的操作，契合最少知识原则</p><p>e.g: <a href="https://github.com/yujiahaol68/design-pattern-learning-ts/blob/master/facade/main.ts" target="_blank" rel="external">Facade</a></p><h3 id="模板方法模式-Template-Method-pattern"><a href="#模板方法模式-Template-Method-pattern" class="headerlink" title="模板方法模式 Template Method pattern"></a>模板方法模式 Template Method pattern</h3><p>这种封装方式可以使得子类在任何时候都可以将自己挂载进运算里，模板方法定义了一个算法步骤，并允许子类为其中的部分步骤提供自己的实现</p><h4 id="核心要点：-3"><a href="#核心要点：-3" class="headerlink" title="核心要点："></a>核心要点：</h4><p>将相同的步骤抽离出来在抽象类中实现，不同的步骤在子类之中分别实现（父类中以抽象方法的形式存在），子类通过调用同一个模板方法去实现各自的功能（功能有部分不同，但单从模板方法中无法得知，因为被统一抽象了）。模板方法中可以加入钩子方法，提供默认的实现或留空以供子类进行覆盖，通过条件进行流程控制我们可以大大增加算法的灵活性，钩子方法通常是算法当中可选的一部分</p><h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景:"></a>常见应用场景:</h4><p>对象排序的时候对象需要先实现一个比较方法</p><h3 id="总结（踩蛋）"><a href="#总结（踩蛋）" class="headerlink" title="总结（踩蛋）"></a>总结（踩蛋）</h3><p>如果看到这里时，你仍然觉得这么多的模式使你头晕脑胀更别说应用的话，请收下这几枚硬干货：</p><ul><li>计算机科学领域的任何问题, 都可以通过添加一个中间层来解决，几乎所有的设计模式都遵循了这个原则来应对变化增加弹性或进行扩展</li><li>抽象与复用是核心需求，摸石们都为了满足这两点而不断地努力着</li><li>没有完美的模式能够完美应对所有的变化</li></ul><p>最后，希望你能够将模式多多应用到业务或编写框架中，尽最大努力编写出干净，可扩展，易维护的架构。</p><p><strong>参考资料:</strong> 《HeadFirst设计模式中文版》2007年第一版</p><p><strong>商业转载请联系作者获得授权，非商业转载请注明出处，谢谢合作！</strong></p><p>联系方式：tecker_yuknigh@163.com</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;若有不足或纰漏，欢迎指教&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h3&gt;&lt;p&gt;得益于TypeScript强大灵活的OOP语法，使得在js中使用经典且可靠的OOP设计模式变成
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://tecknight.xyz/categories/TypeScript/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="TypeScript" scheme="http://tecknight.xyz/tags/TypeScript/"/>
    
      <category term="design pattern" scheme="http://tecknight.xyz/tags/design-pattern/"/>
    
      <category term="learning" scheme="http://tecknight.xyz/tags/learning/"/>
    
  </entry>
  
  <entry>
    <title>使用sftp搭建本地快速部署环境</title>
    <link href="http://tecknight.xyz/2017/09/10/%E4%BD%BF%E7%94%A8sftp%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/"/>
    <id>http://tecknight.xyz/2017/09/10/使用sftp搭建本地快速部署环境/</id>
    <published>2017-09-10T07:11:53.000Z</published>
    <updated>2017-09-10T07:16:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先，我们要确保<code>sshd</code>也就是我们的ssh服务处于运行状态之中，下面以centos为例来讲解搭建的过程。</p><p>必要的包: <code>openssh-clients</code> <code>openssh-server</code></p><p>运行下面的命令以确定我们的ssh服务处于active的状态中</p><pre><code>$ systemctl status sshd</code></pre><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>新建一个用户(非root用户请加sudo)</p><pre><code>$ adduser test</code></pre><pre><code>$ passwd test</code></pre><p>设置密码，更新用户令牌信息，本地生成SSH密钥并将公钥放置于服务器，确保能从本地使用SSH登录远程主机</p><p>明确新用户的文件夹权限</p><pre><code>$ chown root:root /../somepath/sftp$ chmod 755 /../somepath/sftp</code></pre><p>在sftp文件夹下创建<code>uploads</code>文件夹，所有上传的文件都会在里面，将拥有者设置为test用户</p><pre><code>$ chown test:test /../somepath/sftp/uploads</code></pre><p>将<code>PasswordAuthentication</code>设置为<code>no</code>并保存，确保不能用密码建立SSH连接并重启SSH服务</p><pre><code>$ vi /etc/ssh/sshd_config$ ...$ systemctl restart sshd</code></pre><p>现在在本地尝试使用<code>sftp</code>进行登录</p><pre><code>sftp -i ~/.ssh/key test@ip_address</code></pre><p>发现进入sftp即成功！</p><h3 id="使用vscode配置快速部署环境"><a href="#使用vscode配置快速部署环境" class="headerlink" title="使用vscode配置快速部署环境"></a>使用vscode配置快速部署环境</h3><p>这里是用的是 <code>ftp-sync</code> 插件</p><p>安装完成之后按<code>F1</code>键</p><p>选择<code>Ftp-sync: init</code></p><p>就可以在<code>.vscode</code>文件夹下找到<code>ftp-sync.json</code>文件</p><pre><code>{    &quot;remotePath&quot;: &quot;/../sftp/uploads/project&quot;,    &quot;host&quot;: &quot;&quot;,    // ip地址    &quot;username&quot;: &quot;test&quot;,    &quot;password&quot;: null,    // 留空，因为使用了更安全的sftp协议传输文件    &quot;port&quot;: 22,    // SSH端口    &quot;secure&quot;: true,    &quot;protocol&quot;: &quot;sftp&quot;,    &quot;uploadOnSave&quot;: false,    &quot;passive&quot;: false,    &quot;debug&quot;: false,    &quot;privateKeyPath&quot;: &quot;/Users/user/.ssh/key&quot;,  // 本地密钥的地址    &quot;passphrase&quot;: null,    &quot;ignore&quot;: [        &quot;\\.vscode&quot;,        &quot;\\.git&quot;,        &quot;\\.DS_Store&quot;,        &quot;\\node_modules&quot;,        &quot;\\test&quot;,        &quot;\\.travis.yml&quot;        // 想要忽略上传的文件夹或文件    ],    &quot;generatedFiles&quot;: {        &quot;uploadOnSave&quot;: false,        &quot;extensionsToInclude&quot;: [],        &quot;path&quot;: &quot;&quot;    }}</code></pre><p>然后愉快地快速部署到服务器吧</p><p><code>F1</code> </p><p>选择 <code>Ftp-sync: Local To Remote</code></p><p>选择 <code>full-sync</code>，执行上传。大功告成！</p><p>注： 如果是node项目的话可以使用<code>pm2</code>检测文件更改自动重启服务，一键更新线上代码！</p><p>参考：</p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-enable-sftp-without-shell-access-on-centos-7" target="_blank" rel="external">https://www.digitalocean.com/community/tutorials/how-to-enable-sftp-without-shell-access-on-centos-7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;p&gt;首先，我们要确保&lt;code&gt;sshd&lt;/code&gt;也就是我们的ssh服务处于运行状态之中，下面以centos为例来讲解搭建的过程。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="web" scheme="http://tecknight.xyz/tags/web/"/>
    
      <category term="shell" scheme="http://tecknight.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>centOS下的node部署环境搭建</title>
    <link href="http://tecknight.xyz/2017/06/08/centOS%E4%B8%8B%E7%9A%84node%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://tecknight.xyz/2017/06/08/centOS下的node部署环境搭建/</id>
    <published>2017-06-08T08:21:41.000Z</published>
    <updated>2017-06-08T09:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程"><a href="#本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程" class="headerlink" title="本文实践的是单机搭建 nginx+node+mongodb+redis 流行组合的具体过程"></a>本文实践的是单机搭建 nginx+node+mongodb+redis 流行组合的具体过程</h2><p><a href="https://jp.godaddy.com/help/set-up-nodejs-application-for-production-centos-17354" target="_blank" rel="external">node的安装过程详情</a></p><p>其他的直接上亲自实践过的安装命令以及需要注意的地方，习惯用英文注释，部分重点已用中文指出</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token comment" spellcheck="true">#update software</span><span class="token function">sudo</span> yum update -y<span class="token comment" spellcheck="true">#back to root dir</span><span class="token function">cd</span> ~<span class="token comment" spellcheck="true">#Nginx</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> <span class="token function">make</span> zlib zlib-devel gcc-c++ libtool  openssl openssl-devel<span class="token comment" spellcheck="true">#If pcre</span>rpm -qa pcre<span class="token comment" spellcheck="true">#yes download nginx stable version</span><span class="token function">wget</span> http://nginx.org/download/nginx-1.12.0.tar.gz<span class="token function">tar</span> zxvf nginx-1.12.0.tar.gz<span class="token comment" spellcheck="true">#switch to root for mkdir</span><span class="token function">su</span> root<span class="token function">cd</span> nginx-1.12.0./configure <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span><span class="token function">cd</span> ~ <span class="token operator">&amp;&amp;</span> <span class="token keyword">exit</span><span class="token function">rm</span> -rf nginx-1.12.0<span class="token function">rm</span> nginx-1.12.0.tar.gz<span class="token comment" spellcheck="true">#start nginx</span><span class="token comment" spellcheck="true">#access public IP should success</span>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<span class="token comment" spellcheck="true">#self-start config</span><span class="token function">sudo</span> <span class="token function">vi</span> /lib/systemd/system/nginx.service<span class="token comment" spellcheck="true">#content</span><span class="token keyword">:</span><span class="token string">'[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.confExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target'</span>systemctl start nginx.servicesystemctl <span class="token function">enable</span> nginx.service<span class="token comment" spellcheck="true">#check if running</span>systemctl list-units --type<span class="token operator">=</span>service<span class="token comment" spellcheck="true">#Mongodb</span><span class="token function">sudo</span> <span class="token function">vi</span> /etc/yum.repos.d/mongodb-org-3.4.repo<span class="token comment" spellcheck="true">#https://docs.mongodb.com/master/tutorial/install-mongodb-on-red-hat/</span><span class="token comment" spellcheck="true">#content</span><span class="token keyword">:</span><span class="token string">'[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/<span class="token variable">$releasever</span>/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc'</span><span class="token comment" spellcheck="true">#yum install mongodb</span><span class="token function">sudo</span> yum -y <span class="token function">install</span> mongodb-org<span class="token comment" spellcheck="true">#start mongodb(default it can self-start when booting)</span><span class="token function">sudo</span> <span class="token function">service</span> mongod start<span class="token comment" spellcheck="true">#self-start</span><span class="token function">sudo</span> <span class="token function">chkconfig</span> mongod on<span class="token comment" spellcheck="true">#pm2 install</span><span class="token function">sudo</span> cnpm i pm2 -g<span class="token comment" spellcheck="true">#redis</span><span class="token function">wget</span> http://download.redis.io/releases/redis-3.2.9.tar.gz<span class="token function">su</span> root<span class="token function">tar</span> xzf redis-3.2.9.tar.gz<span class="token function">cd</span> redis-3.2.9<span class="token function">make</span><span class="token function">cd</span> src<span class="token function">cp</span> redis-server redis-cli redis-sentinel redis-benchmark redis-check-aof redis-check-rdb /usr/local/bin<span class="token function">mkdir</span> /etc/redis<span class="token function">mkdir</span> -p /var/lib/redis/6379<span class="token function">cp</span> redis.conf /etc/redis/6379.conf<span class="token function">vi</span> /etc/redis/6379.conf<span class="token keyword">:</span><span class="token string">'daemonize yeslogfile /var/log/redis_6379.logdir /var/lib/redis/6379'</span><span class="token function">cp</span> utils/redis_init_script /etc/init.d/redis<span class="token function">vi</span> /lib/systemd/system/redis.service<span class="token comment" spellcheck="true">#content</span><span class="token keyword">:</span><span class="token string">'[Unit]Description=Redis on port 6379[Service]Type=forkingExecStart=/etc/init.d/redis_6379 startExecStop=/etc/init.d/redis_6379 stop[Install]WantedBy=multi-user.targetvm.overcommit_memory = 1net.core.somaxconn=512'</span>systemctl start redis.servicesystemctl <span class="token function">enable</span> redis.service<span class="token function">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> <span class="token punctuation">..</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> -rf redis-3.2.9 redis-3.2.9.tar.gz<span class="token comment" spellcheck="true">#kernel config</span>sysctl -w vm.overcommit_memory<span class="token operator">=</span>1sysctl -w net.core.somaxconn<span class="token operator">=</span>512<span class="token keyword">echo</span> never <span class="token operator">></span> /sys/kernel/mm/transparent_hugepage/enabled<span class="token comment" spellcheck="true">#booting shell</span><span class="token keyword">echo</span> never <span class="token operator">>></span> /sys/kernel/mm/transparent_hugepage/enabled<span class="token keyword">echo</span> never <span class="token operator">>></span> /sys/kernel/mm/transparent_hugepage/defragsystemctl restart mongod.service<span class="token comment" spellcheck="true">#nginx conf ( Remember to configure user !!!)</span><span class="token comment" spellcheck="true">#nginx 配置内容经优化（踩过的坑，最顶部的注释要去掉替换成对应的用户名，否则会无文件权限！！）</span><span class="token comment" spellcheck="true">#其中含负载均衡及反向代理的配置，模仿着配置好就行</span><span class="token keyword">:</span><span class="token string">'#user userNamehttp {    client_header_buffer_size 3k;    client_max_body_size 2m;    client_body_buffer_size 7k;    large_client_header_buffers 2 1k;    client_body_timeout   32;    client_header_timeout 32;    reset_timedout_connection on;    open_file_cache max=200000 inactive=20s;    open_file_cache_valid 30s;    open_file_cache_min_uses 2;    open_file_cache_errors on;    tcp_nopush on;    tcp_nodelay on;    types_hash_max_size 2048;    gzip on;    gzip_disable "MSIE [1-6]\.";    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;    types_hash_max_size 2048;}# 负载均衡upstream pro_name {    server 127.0.0.1:3000;#   balanceServer ip2;#   balanceServer ip3;}server {    listen 80;    server_name pro_name;    charset utf-8;    access_log /var/log/nginx/app.log;    root /home/.../code/...;    location ~ /api/ {        proxy_pass http://pro_name;        proxy_redirect off;        proxy_set_header X-Forwarded-For <span class="token variable">$proxy_add_x_forwarded_for</span>;        proxy_set_header Host <span class="token variable">$http_host</span>;        proxy_set_header X-NginX-Proxy true;        proxy_http_version 1.1;        proxy_read_timeout 7s;    }    location ~ /.ht {        deny all;    }    location ~* \.(css|js|gif|jpe?g|png|ico)$ {        root /home/.../code/...;        expires 168h;    }    location / {        index  index.html index.htm;    }}'</span><span class="token comment" spellcheck="true">#实用nginx命令，养成好习惯</span><span class="token comment" spellcheck="true">#everytime save change of .conf</span>/usr/local/nginx/sbin/nginx -t  <span class="token comment" spellcheck="true">#Check Syntax</span>/usr/local/nginx/sbin/nginx -s reload <span class="token comment" spellcheck="true">#Smooth reload nginx</span><span class="token comment" spellcheck="true">#nginx optimize</span>sysctl -w net.core.somaxconn<span class="token operator">=</span>1024</code></pre><h3 id="最后使用pm2进行node项目的管理，包括简单的监控"><a href="#最后使用pm2进行node项目的管理，包括简单的监控" class="headerlink" title="最后使用pm2进行node项目的管理，包括简单的监控"></a>最后使用pm2进行node项目的管理，包括简单的监控</h3><p>详情请见</p><p><a href="http://pm2.keymetrics.io/" target="_blank" rel="external">pm2进程管理</a></p><p><a href="https://keymetrics.io/" target="_blank" rel="external">keymetrics监控项目</a></p><h3 id="附上腾讯云主机在生产环境下的安全组配置"><a href="#附上腾讯云主机在生产环境下的安全组配置" class="headerlink" title="附上腾讯云主机在生产环境下的安全组配置"></a>附上腾讯云主机在生产环境下的安全组配置</h3><img src="/2017/06/08/centOS下的node部署环境搭建/1.png" alt="1.png" title=""><img src="/2017/06/08/centOS下的node部署环境搭建/2.png" alt="2.png" title="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程&quot;&gt;&lt;a href=&quot;#本文实践的是单机搭建-nginx-node-mongodb-redis-流行组合的具体过程&quot; class=&quot;headerlink&quot; title=&quot;本文
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="centOS" scheme="http://tecknight.xyz/tags/centOS/"/>
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="deploy" scheme="http://tecknight.xyz/tags/deploy/"/>
    
      <category term="环境搭建" scheme="http://tecknight.xyz/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>mongoose下的promise技巧</title>
    <link href="http://tecknight.xyz/2017/05/02/mongoose%E4%B8%8B%E7%9A%84promise%E6%8A%80%E5%B7%A7/"/>
    <id>http://tecknight.xyz/2017/05/02/mongoose下的promise技巧/</id>
    <published>2017-05-02T04:18:46.000Z</published>
    <updated>2017-06-08T08:24:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在Promise大行其道的世界里，使用promise可谓是家常便饭了，写一个漂亮的promise极其重要</p><p>本文将会基于Express环境实战mongoose的promise，帮大家避免一些常见的错误并对promise链进行调整以提高其可读性</p><p>最后，本文将会介绍一种极少见的promise奇淫怪技，解决一些难以解决的又不得不解决的异步冲突</p></blockquote><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>虽然<code>mongoose</code>本身也有自带<code>promise</code>且大部分操作返回就是一个<code>promise</code>对象，但大多数情况下我们还是毅然决然的换成<code>bluebird</code>这个promise库，其中提供了大量的<br>promise操作可供我们使用，废话少说，赶紧上路！</p><h2 id="Bad-example"><a href="#Bad-example" class="headerlink" title="Bad example"></a>Bad example</h2><p>你可能看过这样的<code>Promise</code>链中链</p><pre class=" language-javascript"><code class="language-javascript">user_group<span class="token punctuation">.</span><span class="token function">findByName</span><span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">findUser</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>userObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token operator">...</span><span class="token punctuation">.</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>看到这里不用写都应该能发现，这<code>Promise</code>已经失去了它原本的使命，层层嵌套，犹如又回到了地狱回调的节奏，可读性不免让人觉得糟糕</p><h2 id="Let’s-pratice"><a href="#Let’s-pratice" class="headerlink" title="Let’s pratice"></a>Let’s pratice</h2><p>我们可以来动手改写一下</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续.."></a>未完待续..</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在Promise大行其道的世界里，使用promise可谓是家常便饭了，写一个漂亮的promise极其重要&lt;/p&gt;
&lt;p&gt;本文将会基于Express环境实战mongoose的promise，帮大家避免一些常见的错误并对promise链进行调整以提高其
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="promise" scheme="http://tecknight.xyz/tags/promise/"/>
    
      <category term="mongoose" scheme="http://tecknight.xyz/tags/mongoose/"/>
    
  </entry>
  
  <entry>
    <title>用supertest进行API测试</title>
    <link href="http://tecknight.xyz/2017/04/23/%E7%94%A8supertest%E8%BF%9B%E8%A1%8CAPI%E6%B5%8B%E8%AF%95/"/>
    <id>http://tecknight.xyz/2017/04/23/用supertest进行API测试/</id>
    <published>2017-04-23T00:13:51.000Z</published>
    <updated>2017-04-23T01:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在node开发中，写完了API接口之后，往往都要进行测试，现在常用的测试模块一般都是<code>mocha</code>和<code>chai</code>，<br>然后我们应该有相配合的请求模块来帮助我们更好地完成断言的工作，今天要介绍的主角就是<code>supertest</code></p><p>用过<code>superagent</code>的童鞋应该都知道，<code>supertest</code>的用法同样简洁优雅，本文环境基于<code>Express</code>，废话不说，上实战代码</p><h3 id="GET-请求"><a href="#GET-请求" class="headerlink" title="GET 请求"></a>GET 请求</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> assert <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'chai'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>assert<span class="token punctuation">;</span><span class="token keyword">const</span> request <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'supertest'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> should <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'should'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../../app'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> _ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'lodash'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将supertest设成request是习惯使然</span><span class="token comment" spellcheck="true">// 断言</span><span class="token function">describe</span><span class="token punctuation">(</span><span class="token string">"get /"</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// it描述了API的功能，预期的返回内容</span>    <span class="token function">it</span><span class="token punctuation">(</span><span class="token string">"should respond with ...."</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用supertest进行GET请求，并验证其返回的状态码</span>        <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'Accept'</span><span class="token punctuation">,</span> <span class="token string">'application/json'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//设置请求头</span>            <span class="token punctuation">.</span><span class="token function">expect</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//预期的状态码</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                assert<span class="token punctuation">.</span><span class="token function">notEqual</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">findIndex</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>body<span class="token punctuation">,</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 使用assert断言库进行断言，如果lodash找不到json中的最外层的键值对(找里面的话可以在body的基础上继续访问)</span>                    <span class="token comment" spellcheck="true">// 使用equal或者是to.include.keys('key')也是可以的</span>                    <span class="token string">'key'</span> <span class="token punctuation">:</span> <span class="token string">'value'</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 前面不再赘述，我们专注于supertest</span><span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/search'</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span> key<span class="token punctuation">:</span> <span class="token string">'value'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// x-www-form-urlencoded</span>        <span class="token punctuation">.</span><span class="token function">field</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'Jack'</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// form-data</span>        <span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span><span class="token string">'avatar'</span><span class="token punctuation">,</span> <span class="token string">'test/fixtures/homeboy.jpg'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// post上传附件</span></code></pre><h3 id="PUT或DELETE请求"><a href="#PUT或DELETE请求" class="headerlink" title="PUT或DELETE请求"></a>PUT或DELETE请求</h3><p>同理</p><pre class=" language-javascript"><code class="language-javascript"><span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span><span class="token string">'/path'</span><span class="token punctuation">)</span><span class="token function">request</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'/path'</span><span class="token punctuation">)</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在node开发中，写完了API接口之后，往往都要进行测试，现在常用的测试模块一般都是&lt;code&gt;mocha&lt;/code&gt;和&lt;code&gt;chai&lt;/code&gt;，&lt;br&gt;然后我们应该有相配合的请求模块来帮助我们更好地完成断言的工作，今天要介绍的主角就是&lt;code&gt;superte
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="Express" scheme="http://tecknight.xyz/tags/Express/"/>
    
      <category term="api" scheme="http://tecknight.xyz/tags/api/"/>
    
      <category term="test" scheme="http://tecknight.xyz/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>最精简restful实现</title>
    <link href="http://tecknight.xyz/2017/04/12/%E6%9C%80%E7%B2%BE%E7%AE%80restful%E5%AE%9E%E7%8E%B0/"/>
    <id>http://tecknight.xyz/2017/04/12/最精简restful实现/</id>
    <published>2017-04-12T14:25:23.000Z</published>
    <updated>2017-04-12T14:31:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Time-is-short-Just-show-me-the-code"><a href="#Time-is-short-Just-show-me-the-code" class="headerlink" title="Time is short. Just show me the code!"></a>Time is short. Just show me the code!</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> url <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'url'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> items <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*附上测试方法curl -X GET http://localhost:3000curl -X POST -d "Node should test in action" http://localhost:3000curl -X DELETE http://localhost:3000/1curl -X PUT -d "Pratice node every day" http://localhost:3000/1*/</span><span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// method include POST,GET,DELETE,PUT</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">'POST'</span><span class="token punctuation">:</span>            <span class="token keyword">var</span> item <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// convert bytes to utf-8 encoding data</span>            req<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// listening data event, POST data will send to server by chunk (bytes array)</span>            req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>                item <span class="token operator">+</span><span class="token operator">=</span>chunk<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                items<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'OK\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'GET'</span><span class="token punctuation">:</span>            items<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token string">') '</span> <span class="token operator">+</span> element <span class="token operator">+</span> <span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'DELETE'</span><span class="token punctuation">:</span>            <span class="token keyword">var</span> path <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>pathname<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//get string '/1'</span>            <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// convert String to Number</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Invalid item id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Item not found!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                items<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'delete success!\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">'PUT'</span><span class="token punctuation">:</span>            <span class="token keyword">var</span> newItem <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> putPath <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span>pathname<span class="token punctuation">;</span>            <span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>putPath<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Invalid item id'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span>statusCode <span class="token operator">=</span> <span class="token number">404</span><span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'item not found!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                req<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    newItem <span class="token operator">+</span><span class="token operator">=</span> chunk<span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                items<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> newItem<span class="token punctuation">;</span>                res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'update success!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Time-is-short-Just-show-me-the-code&quot;&gt;&lt;a href=&quot;#Time-is-short-Just-show-me-the-code&quot; class=&quot;headerlink&quot; title=&quot;Time is short. Just sh
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="native" scheme="http://tecknight.xyz/tags/native/"/>
    
      <category term="RESTFul" scheme="http://tecknight.xyz/tags/RESTFul/"/>
    
  </entry>
  
  <entry>
    <title>python 语法基础</title>
    <link href="http://tecknight.xyz/2017/04/11/python-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://tecknight.xyz/2017/04/11/python-语法基础/</id>
    <published>2017-04-11T12:58:59.000Z</published>
    <updated>2017-04-11T13:01:01.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="其中记录了python跟别的语言不一样的一些基础知识点"><a href="#其中记录了python跟别的语言不一样的一些基础知识点" class="headerlink" title="其中记录了python跟别的语言不一样的一些基础知识点"></a>其中记录了python跟别的语言不一样的一些基础知识点</h4><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p><code>True</code></p><p><code>False</code></p><h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p><code>/</code> 默认的除法是精确除法</p><p><code>//</code> 才是通常的取商的整数部分</p><h4 id="字符-类似C的ASCII码"><a href="#字符-类似C的ASCII码" class="headerlink" title="字符(类似C的ASCII码)"></a>字符(类似C的ASCII码)</h4><p><code>ord()</code> 字符对应编码</p><p><code>chr()</code> 编码转字符</p><p><code>&#39;aaa&#39;.encode(&#39;utf-8&#39;)</code> 转成对应编码形式的<code>bytes</code></p><p><code>&#39;aaa&#39;.decode(&#39;utf-8&#39;)</code> 从<code>bytes</code>转成<code>utf-8</code>编码</p><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><pre class=" language-python"><code class="language-python">r <span class="token operator">=</span> <span class="token number">18.0555</span><span class="token string">'%.2f%%'</span> <span class="token operator">%</span>r<span class="token comment" spellcheck="true"># '18.06%'</span></code></pre><h4 id="数据类型之list-类比数组"><a href="#数据类型之list-类比数组" class="headerlink" title="数据类型之list(类比数组)"></a>数据类型之list(类比数组)</h4><p>获取<code>list</code>元素个数<code>len(变量名)</code></p><p>访问元素下标为负表示都是第几个元素</p><p>末尾添加元素 <code>vary.append(...)</code></p><p>插入指定位置 <code>vary.insert(1, &#39;Jack&#39;)</code></p><p>末尾元素去除 <code>vary.pop()</code></p><p>去除指定位置 <code>vary.pop(2)</code></p><p>元素之间的数据类型可不同</p><h4 id="数据类型之tuple元组"><a href="#数据类型之tuple元组" class="headerlink" title="数据类型之tuple元组"></a>数据类型之tuple元组</h4><p>与<code>list</code>相比这样定义出来的数组内的元素是不可直接变的，数据更加安全</p><p>间接改变的原理：<code>tuple是保持元素的指向不变，指向的内容是可能可变的，例如元素是list</code></p><pre class=" language-python"><code class="language-python">t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span></code></pre><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p><code>:</code> 替代花括号块</p><p><code>elif</code> 等价于其他语言的 <code>else if</code></p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><code>for-in</code> 循环    <code>for x in ...:</code></p><p><code>continue</code> 打破当前循环进入下一次循环</p><p><code>break</code> 退出循环体</p><h4 id="dict-键值对"><a href="#dict-键值对" class="headerlink" title="dict 键值对"></a>dict 键值对</h4><pre class=" language-python"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'A'</span><span class="token punctuation">:</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">:</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">:</span><span class="token number">33</span><span class="token punctuation">}</span>d<span class="token punctuation">[</span><span class="token string">'B'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 22</span></code></pre><p>找不到<code>key</code>时会报错，所以查<code>key</code>之前要判断一下<code>key in d</code>的返回值再查找</p><p>或者</p><p><code>d.get(&#39;B&#39;, -1)</code> 第二个参数指定了找不到时返回的值</p><p><code>dict</code> 中的<code>key</code>不可变</p><p>删除 <code>d.pop(key)</code></p><h4 id="set-key的集合"><a href="#set-key的集合" class="headerlink" title="set key的集合"></a>set key的集合</h4><p>初始化需传入一个<code>list</code>，传入的元素不能有重复的</p><pre class=" language-python"><code class="language-python">s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># {5, 6, 7}</span></code></pre><p>添加 <code>add(key)</code></p><p>删除 <code>remove(key)</code></p><h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p><code>str.remove(&#39;a&#39;, &#39;A&#39;)</code>将<code>a</code>替换成<code>A</code>但是方法会返回一个新的串，原来的<code>str</code>不可变！</p><h4 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h4><p><code>abs()</code></p><p><code>max()</code> 可以放任意个参数只返回最大</p><p><code>a = abs</code> 给<code>abs</code>函数引用发给<code>a</code>，调用<code>a()</code>效果一样</p><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>int(要转换的变量)</code></p><p>其他类似</p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p><code>def</code> 替代<code>function</code></p><h4 id="缩进体置空"><a href="#缩进体置空" class="headerlink" title="缩进体置空"></a>缩进体置空</h4><p><code>pass</code></p><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>居然可以有多个!! 我的三观…</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">goBack</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>    <span class="token keyword">return</span> x<span class="token punctuation">,</span>ya<span class="token punctuation">,</span>b <span class="token operator">=</span> goBack<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>原因：返回的是<code>tuple</code></p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">goBack</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>    <span class="token keyword">if</span> isinstance<span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">(</span>int<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> x<span class="token punctuation">,</span>y<span class="token comment" spellcheck="true"># 允许int和float类型</span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> n<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># n默认值为2</span></code></pre><p><code>默认参数必须指向不变对象</code></p><p>参数可以是 <code>list</code> 或者 <code>tuble</code>，利用可变参数</p><p>可变参数 <code>def calc(*numbers):</code> 多参数自动组装成<code>tuple</code></p><p>关键字参数 <code>def person(name, age, **kw):</code> 方便扩展函数的参数</p><p><code>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</code></p><h4 id="尾递归优化递归函数"><a href="#尾递归优化递归函数" class="headerlink" title="尾递归优化递归函数"></a>尾递归优化递归函数</h4><p><code>指在函数返回的时候，调用自身本身，并且，return语句不能包含表达式</code></p><p>注意：标准解释器并不支持这种用法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;其中记录了python跟别的语言不一样的一些基础知识点&quot;&gt;&lt;a href=&quot;#其中记录了python跟别的语言不一样的一些基础知识点&quot; class=&quot;headerlink&quot; title=&quot;其中记录了python跟别的语言不一样的一些基础知识点&quot;&gt;&lt;/a&gt;其中记录了
      
    
    </summary>
    
      <category term="python" scheme="http://tecknight.xyz/categories/python/"/>
    
    
      <category term="python" scheme="http://tecknight.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习的常用概念</title>
    <link href="http://tecknight.xyz/2017/04/08/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A6%82%E5%BF%B5/"/>
    <id>http://tecknight.xyz/2017/04/08/机器学习的常用概念/</id>
    <published>2017-04-08T11:28:52.000Z</published>
    <updated>2017-04-08T15:05:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="特征-属性"><a href="#特征-属性" class="headerlink" title="特征(属性)"></a>特征(属性)</h4><p>通常是训练样本集的列，可看作是每个列的列名，比如区分鸟的品种可以用体重，后背颜色此类的特征来加以区分</p><h4 id="特征实例"><a href="#特征实例" class="headerlink" title="特征实例"></a>特征实例</h4><p>某一特征列其中的数据</p><h4 id="特征的种类"><a href="#特征的种类" class="headerlink" title="特征的种类"></a>特征的种类</h4><ul><li>数值型</li><li>二值型(类似布尔型)</li><li>枚举类型(颜色色值)</li></ul><h4 id="训练集"><a href="#训练集" class="headerlink" title="训练集"></a>训练集</h4><p>训练集是用于训练机器学习算法的数据样本集合</p><h4 id="训练样本"><a href="#训练样本" class="headerlink" title="训练样本"></a>训练样本</h4><p>样本集的每一行就是一个训练样本</p><h4 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h4><p>机器学习算法的预测结果</p><p>分类:</p><ul><li>分类算法中，通常为标称型，目标变量称为<code>类别</code></li><li>回归算法中，通常为连续型</li></ul><p>训练样本集前必须要确定目标变量的值，比如根据鸟的身高，体重，颜色这些特征可以具体确定鸟的品种，品种就是目标变量，<br>而品种的值就是具体的品种名称，也就是目标变量的值</p><h4 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h4><p>指展示机器分类的结果的工作</p><p>形式包括：<code>规则集</code> <code>概率分布</code> <code>训练样本集中的实例</code> </p><h4 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h4><p>以便机器学习算法发现特征与目标变量的关系</p><p><em>机器学习的主要任务就是分类</em></p><p>将实例数据划分到合适的分类中</p><p>分类的基本流程：</p><ol><li>得到全部特征信息</li><li>算法训练(学习如何分类)</li><li>测试机器学习算法的效果</li></ol><h4 id="如何测试算法的效果？"><a href="#如何测试算法的效果？" class="headerlink" title="如何测试算法的效果？"></a>如何测试算法的效果？</h4><p>为了测试效果，通常会使用两套独立的样本集：<code>训练数据</code> 和 <code>测试数据</code></p><p><em>机器学习另外一个重要的任务：回归</em></p><p>主要用于预测数值型数据</p><h4 id="程序开始运行"><a href="#程序开始运行" class="headerlink" title="程序开始运行:"></a>程序开始运行:</h4><p>训练样本集提供目标变量 =&gt; 输入到算法 =&gt; 训练完成 =&gt; 输入测试数据(不包含目标变量) =&gt; 比较测试结果与实际目标变量的差别(回归拟合) =&gt; 得出算法的实际精确度</p><h4 id="监督学习与无监督学习"><a href="#监督学习与无监督学习" class="headerlink" title="监督学习与无监督学习"></a>监督学习与无监督学习</h4><p>监督学习指算法知道预测什么，也就是有明确的目标</p><p>回归和分类都是属于监督学习</p><p>与监督学习相比，无监督学习没有目标值</p><h3 id="非监督学习"><a href="#非监督学习" class="headerlink" title="非监督学习"></a>非监督学习</h3><p>作用：</p><ul><li>减少数据特征的维度</li></ul><h4 id="聚类-分析"><a href="#聚类-分析" class="headerlink" title="聚类(分析)"></a>聚类(分析)</h4><p>把相似的对象通过静态分类的方法分成不同组别或者更多的子集，相当于是把一个训练集分成了多个训练集，每个新训练集中的数据的特征相似</p><h4 id="密度估计"><a href="#密度估计" class="headerlink" title="密度估计"></a>密度估计</h4><p>指寻找描述数据统计值的过程，可以理解为要得到关于描述数据的 <code>频率分布直方图</code>，降低特征维度，使其更直观</p><h3 id="浅谈算法的选择"><a href="#浅谈算法的选择" class="headerlink" title="浅谈算法的选择"></a>浅谈算法的选择</h3><ul><li>以目的为导向：根据要完成的任务，选择监督学习的或者是非监督学习的算法</li><li>以数据来源为导向：需要分析或收集的数据是什么</li></ul><h3 id="开发机器学习应用程序的大概步骤"><a href="#开发机器学习应用程序的大概步骤" class="headerlink" title="开发机器学习应用程序的大概步骤"></a>开发机器学习应用程序的大概步骤</h3><ol><li><p>收集数据</p></li><li><p>准备输入数据</p></li><li><p>分析输入数据(人工)</p></li><li><p>训练算法(机器学习)</p></li><li><p>测试算法</p></li><li><p>使用算法</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;特征-属性&quot;&gt;&lt;a href=&quot;#特征-属性&quot; class=&quot;headerlink&quot; title=&quot;特征(属性)&quot;&gt;&lt;/a&gt;特征(属性)&lt;/h4&gt;&lt;p&gt;通常是训练样本集的列，可看作是每个列的列名，比如区分鸟的品种可以用体重，后背颜色此类的特征来加以区分&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Machine Learning" scheme="http://tecknight.xyz/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://tecknight.xyz/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Linux WEB基础 学习笔记</title>
    <link href="http://tecknight.xyz/2017/03/29/Linux-WEB%E5%9F%BA%E7%A1%80-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://tecknight.xyz/2017/03/29/Linux-WEB基础-学习笔记/</id>
    <published>2017-03-29T04:39:21.000Z</published>
    <updated>2017-03-29T05:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统版本选择"><a href="#系统版本选择" class="headerlink" title="系统版本选择"></a>系统版本选择</h2><ul><li>根据不同发行版本的特性</li></ul><h3 id="red-hat-企业（付费）"><a href="#red-hat-企业（付费）" class="headerlink" title="red hat 企业（付费）"></a>red hat 企业（付费）</h3><h3 id="ubuntu-跨设备：服务器，台式，笔记本，嵌入式设备"><a href="#ubuntu-跨设备：服务器，台式，笔记本，嵌入式设备" class="headerlink" title="ubuntu 跨设备：服务器，台式，笔记本，嵌入式设备"></a>ubuntu 跨设备：服务器，台式，笔记本，嵌入式设备</h3><h3 id="debian-稳定可靠，但更新周期长"><a href="#debian-稳定可靠，但更新周期长" class="headerlink" title="debian 稳定可靠，但更新周期长"></a>debian 稳定可靠，但更新周期长</h3><h3 id="Mint-台式机用户并支持专利性媒体"><a href="#Mint-台式机用户并支持专利性媒体" class="headerlink" title="Mint 台式机用户并支持专利性媒体"></a>Mint 台式机用户并支持专利性媒体</h3><h3 id="Core-OS-容器化应用程序的计算机集群建设"><a href="#Core-OS-容器化应用程序的计算机集群建设" class="headerlink" title="Core OS 容器化应用程序的计算机集群建设"></a>Core OS 容器化应用程序的计算机集群建设</h3><h2 id="系统路径"><a href="#系统路径" class="headerlink" title="系统路径"></a>系统路径</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">pwd</span></code></pre><p><strong>返回当前的目录位置</strong></p><p><code>/</code>表示系统的根目录，可以进入的最高位置</p><p>所有<code>Linux</code>系统中都可以找到<code>/home</code>这样的目录，除少数例外情况，<code>home</code>目录可以容纳每个用户的所有主目录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -a</code></pre><p><strong>显示所有文件包括隐藏文件</strong></p><p>任何前缀是<code>.</code>的文件都是会被系统隐藏的</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ls</span> -al</code></pre><p>以长格式打印所有文件信息</p><img src="/2017/03/29/Linux-WEB基础-学习笔记/2.png" alt="2.png" title=""><pre class=" language-bash"><code class="language-bash">drwxr-xr-x 4 root root 4096 Jul 2 21:00 <span class="token punctuation">..</span></code></pre><p>首字符为d，代表这个结果是目录，<code>-</code>代表文件</p><p>后面的每三个分割开来看，分别对应所有者<code>owner</code>，组<code>group</code>，所有人<code>everyone</code></p><p>分别是读，写和是否为可执行文件对应字母为<code>r</code>,<code>w</code>,<code>x</code></p><p>后面紧接着就是所有者和组，linux在创建用户的时候会自动创建相同名字的组</p><h2 id="根目录常用文件夹"><a href="#根目录常用文件夹" class="headerlink" title="根目录常用文件夹"></a>根目录常用文件夹</h2><p><code>etc</code> 存储配置文件，配置服务器的时候就会修改其中的文件</p><p><code>var</code> 存储可变的文件，里面的文件一般会随着时间的推移而变大，可找到系统日志和应用程序日志</p><p><code>bin</code> 用于存储可执行的二进制文件，所有用户都可以访问，一般在启动时和系统维护进程中用到</p><p><code>sbin</code> 与<code>bin</code>类似除了其中的可执行文件只能被<code>root</code>用户用于系统管理和维护</p><p><code>lib</code> 存储支持系统中存储的二进制文件的库文件</p><p><code>usr</code> 用于存储用户程序</p><h2 id="命令的运行过程"><a href="#命令的运行过程" class="headerlink" title="命令的运行过程"></a>命令的运行过程</h2><ol><li>输入<code>ls</code></li><li>系统在<code>$path</code>中按顺序寻找路径下名称为<code>ls</code>的可执行文件</li><li>找到在<code>bin</code>中</li></ol><h2 id="Linux-安全"><a href="#Linux-安全" class="headerlink" title="Linux 安全"></a>Linux 安全</h2><h3 id="使用最少权限"><a href="#使用最少权限" class="headerlink" title="使用最少权限"></a>使用最少权限</h3><p><strong>超级用户root</strong></p><p>通常情况下，我们禁用root的可远程访问权限，用自己创建的身份登录，然后通过其他命令，我们也可以以root身份运行超级用户的命令，使服务器在用户名及密码未知的情况下被攻破的可能性得到降低</p><p>普通用户可以在命令前面加上<code>sudo</code>来以<code>root</code>的身份运行命令，其中的好处是会出现警告，提前预知危险</p><h3 id="使用包管理软件"><a href="#使用包管理软件" class="headerlink" title="使用包管理软件"></a>使用包管理软件</h3><p>所有可用的程序包来源都会列在<code>/etc/apt/sources.list</code>文件中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update</code></pre><p>更新仓库源，并不会对系统进行更改</p><p>真正升级包要使用</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade</code></pre><h4 id="包finger的使用"><a href="#包finger的使用" class="headerlink" title="包finger的使用"></a>包finger的使用</h4><p>用途：用于查询用户的各种信息打印成易于阅读的格式</p><p>Command</p><pre class=" language-bash"><code class="language-bash">fingerfinger 用户名</code></pre><p>用户信息大部分都存储在<code>/etc/passwd</code>中，用<code>cat</code>打开如下</p><img src="/2017/03/29/Linux-WEB基础-学习笔记/1.png" alt="1.png" title=""><p>文件中的每一行代表一个单独的用户，每个条目包含数个由冒号隔开的字段</p><p>第一个字段是指用户名，第二个用于存储加密的密码，第三和第四字段分别存储用户的ID和组ID，第五个字段用于存储更多说明，最后两个是用户的主目录和用户默认的<code>shell</code>，可以看到，linux的<code>root</code>用户的组ID和用户ID都是0</p><h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><ul><li>创建新用户</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> adduser student</code></pre><ul><li>远程SSH登录</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> student@127.0.0.1 -p 2222</code></pre><p><code>用户名@IP地址</code></p><p><code>-p 端口号</code></p><ul><li>赋予<code>sudo</code>权限</li></ul><p>有sudo权限的用户登录执行</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> /etc/sudoers</code></pre><p>ubuntu中有<code>sudo</code>权限的用户都在<code>/etc/sudoers.d</code>中</p><p>可使用已有的用户进行<code>cp</code>成用户名，然后用<code>nano</code>进行编辑</p><p>将名字改为用户名保存</p><ul><li>强制下次登录时重置密码</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">passwd</span> -e 用户名</code></pre><h3 id="基于密钥的身份验证"><a href="#基于密钥的身份验证" class="headerlink" title="基于密钥的身份验证"></a>基于密钥的身份验证</h3><h4 id="公共密钥加密"><a href="#公共密钥加密" class="headerlink" title="公共密钥加密"></a>公共密钥加密</h4><p>服务器发送任意消息至客户端，客户端用私有密钥进行加密，再将加密后的消息发送给服务器，服务器用公共密钥进行解密，如果与服务器发送的值相等，那么通过</p><p><strong>私有密钥要自己保留</strong></p><h4 id="在本地生成密钥对"><a href="#在本地生成密钥对" class="headerlink" title="在本地生成密钥对"></a>在本地生成密钥对</h4><pre class=" language-bash"><code class="language-bash">ssh-keygen</code></pre><p>为密钥添加密码</p><p>生成的<code>.pub</code>文件就是放在服务器上用于密码身份验证的文件</p><h4 id="将公钥放在服务器上"><a href="#将公钥放在服务器上" class="headerlink" title="将公钥放在服务器上"></a>将公钥放在服务器上</h4><p>登录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">mkdir</span> .ssh<span class="token function">touch</span> .ssh/authorized_keys</code></pre><p>拷贝本地的密钥内容至服务器更创建的文件中，并为文件设置权限</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> 700 .ssh<span class="token function">chmod</span> 644 .ssh/authorized_keys</code></pre><p>使用ssh密钥登录</p><pre class=" language-bash"><code class="language-bash"><span class="token function">ssh</span> student@127.0.0.1 -p 2222 -i ~/.ssh/密钥名称</code></pre><h4 id="禁用密码登录"><a href="#禁用密码登录" class="headerlink" title="禁用密码登录"></a>禁用密码登录</h4><ul><li>编辑<code>SSHD</code>配置文件</li></ul><p>SSHD: 运行于服务器上监听SSH连接的服务</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">nano</span> /etc/ssh/sshd_config</code></pre><p>将<code>PasswordAuthentication</code>设置为<code>no</code>保存</p><p>然后重启服务，让它重新读取配置文件</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> <span class="token function">ssh</span> restart</code></pre><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><img src="/2017/03/29/Linux-WEB基础-学习笔记/3.png" alt="3.png" title=""><h4 id="数字与权限的关系"><a href="#数字与权限的关系" class="headerlink" title="数字与权限的关系"></a>数字与权限的关系</h4><p>r = 4</p><p>w = 2</p><p>x = 1</p><p>无需权限，值为0</p><p>加在一起即为要进行应用的全部权限数量（注意只是对于一种用户）</p><p><strong>系统需要一次处理三个权限，以一次设置用户，组和所有人的权限</strong></p><h4 id="更改文件权限"><a href="#更改文件权限" class="headerlink" title="更改文件权限"></a>更改文件权限</h4><pre><code>chmod 数字 文件夹或文件 //改权限chown 所有者 文件 //更改所有者chgrp 组名 文件名 //更改组</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>每个应用程序都会被分配端口来处理各自的请求</p><p>常见端口如下图</p><img src="/2017/03/29/Linux-WEB基础-学习笔记/4.png" alt="4.png" title=""><p>通过防火墙，可以控制服务器允许哪个端口接受请求</p><h4 id="只开放让应用程序行使正常功能的端口"><a href="#只开放让应用程序行使正常功能的端口" class="headerlink" title="只开放让应用程序行使正常功能的端口"></a>只开放让应用程序行使正常功能的端口</h4><h4 id="ubuntu-ufw-防火墙"><a href="#ubuntu-ufw-防火墙" class="headerlink" title="ubuntu ufw 防火墙"></a>ubuntu ufw 防火墙</h4><p>激活<code>ufw</code></p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> ufw status //查看状态</code></pre><p><strong>写入防火墙规则并开启防火墙</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token function">sudo</span> ufw default deny incoming  //阻止所有 default allow outgoing 允许所有<span class="token function">sudo</span> ufw allow <span class="token function">ssh</span>    //允许开放SSH连接端口<span class="token function">sudo</span> ufw allow www     //允许HTTP请求<span class="token function">sudo</span> ufw <span class="token function">enable</span>        //开启防火墙</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;系统版本选择&quot;&gt;&lt;a href=&quot;#系统版本选择&quot; class=&quot;headerlink&quot; title=&quot;系统版本选择&quot;&gt;&lt;/a&gt;系统版本选择&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;根据不同发行版本的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;red-hat-企业（付费）&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="web" scheme="http://tecknight.xyz/tags/web/"/>
    
      <category term="shell" scheme="http://tecknight.xyz/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Express下多次callback引发的问题</title>
    <link href="http://tecknight.xyz/2017/03/23/Express%E4%B8%8B%E5%A4%9A%E6%AC%A1callback%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://tecknight.xyz/2017/03/23/Express下多次callback引发的问题/</id>
    <published>2017-03-23T15:26:43.000Z</published>
    <updated>2017-03-25T03:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误结果"><a href="#错误结果" class="headerlink" title="错误结果"></a>错误结果</h3><blockquote><p>Error: Can’t render headers after they are sent to the client.</p><p>错误：当响应头被发回客户端时不能被正确渲染！</p></blockquote><h3 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h3><blockquote><p>Express环境下使用mongoose model 进行模糊查询时，需要用ORM进行至少一次至多两次的查询，查询用的都是Promise进行的异步操作</p></blockquote><h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><ul><li><p><strong>响应头的设置出现了冲突</strong>  </p></li><li><p>是<code>res.send(docs)</code>出错</p></li><li><p><strong>调试时移除了其中一个<code>Promise</code>查询，错误消失</strong></p></li><li><p>问题出在<code>Promise</code>上</p></li></ul><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><strong>为什么连续的两个<code>Promise</code>回调会最终导致响应头渲染冲突?</strong></p><p>渲染冲突出现在错误的顶部，跟错误抛出的顺序有关，这与<code>Express</code>自带的<code>res</code>对象有关，而<code>res</code>又继承自<code>node.js</code>原生的<code>http.ServerResponse</code> 类，在<code>res</code>调用<code>res.writeHead(statusCode)</code>写入响应头的状态码之前，我们可以尽情的写入响应头的头信息，在一个<code>res.send(docs)</code>中，应该包含着以下几步，有的是<code>exprerss</code>自己的，有的则是属于<code>node</code>原生<code>http</code>模块的</p><p><strong>按以下顺序开始运行:</strong></p><blockquote><p>res.writeContinue()</p><p>res.statusCode = 404</p><p>res.setHeader(name, value)</p><p>res.getHeader(name)</p><p>res.removeHeader(name)</p><p>res.header(key[, val]) (Express only)</p><p>res.charset = ‘utf-8’ (Express only)</p><p>res.contentType(type) (Express only)</p><p>res.send([body]) (Express only)</p></blockquote><p>最后我们的查询数据是以响应内容中的<code>body</code>的形式返回给客户端的，当要进行<code>send</code>的时候，<code>node</code>自带的函数就会先运行，当然运行第一个<code>Promise</code>的时候是没有问题的，问题在于:<strong><code>send</code>本身并不能中断当前执行的任务</strong>，只要还没有<code>return</code>，代码仍然会继续运行，这也恰恰印证了<code>node</code>的异步非阻塞IO的特性，即便是第一个<code>Promise</code>执行时，并不会阻塞第二个<code>Promise</code>的继续执行，如果第一个<code>Promise</code>的<code>res.send</code>已经执行，当第二个<code>Promise</code>被执行时，执行至第三步，也就是设置响应头的时候原先的响应头信息依然存在，触犯了<strong><code>node</code></strong>中不能重复设置响应头信息的规定，所以<code>node</code>先抛错，这一切看起来也就顺其自然了</p><h3 id="All-in-all-解决方案呢？"><a href="#All-in-all-解决方案呢？" class="headerlink" title="All in all 解决方案呢？"></a>All in all 解决方案呢？</h3><ul><li>避免使用多次<code>send</code>,多次设置响应头就会出现此错误</li><li>谨慎使用异步<code>Promise</code>，可以考虑<code>Promise</code>嵌套<strong>（推荐）</strong></li><li><code>send</code>之前记得加上<code>return</code>让后面的代码不会运行，但这个方法不好难以控制，当异步操作写在一起的时候，谁知道会是哪一个家伙先结束呢？ </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;错误结果&quot;&gt;&lt;a href=&quot;#错误结果&quot; class=&quot;headerlink&quot; title=&quot;错误结果&quot;&gt;&lt;/a&gt;错误结果&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Error: Can’t render headers after they are sent t
      
    
    </summary>
    
      <category term="Node" scheme="http://tecknight.xyz/categories/Node/"/>
    
    
      <category term="node" scheme="http://tecknight.xyz/tags/node/"/>
    
      <category term="Express" scheme="http://tecknight.xyz/tags/Express/"/>
    
      <category term="问题总结" scheme="http://tecknight.xyz/tags/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    
      <category term="异步" scheme="http://tecknight.xyz/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="Debug" scheme="http://tecknight.xyz/tags/Debug/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 升级最新版本git</title>
    <link href="http://tecknight.xyz/2017/03/11/CentOS-7-%E5%8D%87%E7%BA%A7%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%ACgit/"/>
    <id>http://tecknight.xyz/2017/03/11/CentOS-7-升级最新版本git/</id>
    <published>2017-03-11T02:30:11.000Z</published>
    <updated>2017-03-29T04:38:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作:"></a>准备工作:</h3><blockquote><p>CentOS 上的最新git版本也只有1.8.3，就想试着装上最新的版本，没想到差点玩脱，全当记录一次冒险经历</p></blockquote><ul><li>Development tools 没装的要装上，不然GCC编译时会出错</li></ul><pre><code># yum -y groupinstall Development tools</code></pre><ul><li>再卸载CentOS自带的老版本git </li></ul><pre><code># yum -y remove git</code></pre><h3 id="下载git并安装"><a href="#下载git并安装" class="headerlink" title="下载git并安装"></a>下载git并安装</h3><pre><code># cd /usr/src# wget https://www.kernel.org/pub/software/scm/git/git-2.12.0.tar.gz# tar xzf git-2.12.0.tar.gz</code></pre><h4 id="安装注意事项："><a href="#安装注意事项：" class="headerlink" title="安装注意事项："></a>安装注意事项：</h4><pre><code># cd git-2.12.0# make prefix=/usr/local/git all</code></pre><p>此时报错</p><pre class=" language-bash"><code class="language-bash">/usr/src/git-2.12.0/utf8.c:463：对‘libiconv’未定义的引用libgit.a<span class="token punctuation">(</span>utf8.o<span class="token punctuation">)</span>：在函数‘reencode_string_len’中：/usr/src/git-2.12.0/utf8.c:524：对‘libiconv_open’未定义的引用/usr/src/git-2.12.0/utf8.c:535：对‘libiconv_close’未定义的引用/usr/src/git-2.12.0/utf8.c:529：对‘libiconv_open’未定义的引用collect2: 错误：ld 返回 1make: *** <span class="token punctuation">[</span>git-credential-store<span class="token punctuation">]</span> 错误 1</code></pre><p>原方案：</p><pre><code># make prefix=/usr/local/git all# make prefix=/usr/local/git install</code></pre><p>解决方案：</p><p>可替换为</p><pre><code># ./configure --without-iconv# make CFLAGS=-liconv prefix=/usr/local/git all# make CFLAGS=-liconv prefix=/usr/local/git install</code></pre><h3 id="最后将git加入环境变量"><a href="#最后将git加入环境变量" class="headerlink" title="最后将git加入环境变量"></a>最后将git加入环境变量</h3><pre><code># echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc# source /etc/bashrc</code></pre><p><strong>大功告成！查看一下git的版本</strong></p><pre><code># git --version&gt;&gt; git version 2.12.0</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作:&quot;&gt;&lt;/a&gt;准备工作:&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;CentOS 上的最新git版本也只有1.8.3，就想试着装上最新的版本，没想到差点玩脱，全当
      
    
    </summary>
    
      <category term="Linux" scheme="http://tecknight.xyz/categories/Linux/"/>
    
    
      <category term="linux" scheme="http://tecknight.xyz/tags/linux/"/>
    
      <category term="centOS" scheme="http://tecknight.xyz/tags/centOS/"/>
    
      <category term="git" scheme="http://tecknight.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 快速入门</title>
    <link href="http://tecknight.xyz/2017/03/01/vue-router-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://tecknight.xyz/2017/03/01/vue-router-快速入门/</id>
    <published>2017-03-01T10:00:37.000Z</published>
    <updated>2017-03-22T12:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> vue-router --save</code></pre><a id="more"></a><p>routes.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'./pages/Home.vue'</span><span class="token keyword">import</span> Gifs <span class="token keyword">from</span> <span class="token string">'./pages/Gifs.vue'</span><span class="token keyword">import</span> User <span class="token keyword">from</span> <span class="token string">'./pages/User.vue'</span><span class="token keyword">export</span> <span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> Home <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/gifs'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> Gifs <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'/user/:id'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> User <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//指定路由和对应要渲染的组件</span>    <span class="token comment" spellcheck="true">//404的path应该是'*',要放在最末尾，当前面的都匹配不到时才匹配到404页面</span>    <span class="token comment" spellcheck="true">//this.$route.params.id 可以从路由中拿到id数据</span><span class="token punctuation">]</span></code></pre><p>main.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> VueRouter <span class="token keyword">from</span> <span class="token string">'vue-router'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> routes <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./routes'</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>VueRouter<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//路由初始化</span><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  routes<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将路由注入根组件</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  <span class="token operator">...</span>  router<span class="token punctuation">,</span>  render<span class="token punctuation">:</span> h <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>App.vue</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-view</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-view</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span></code></pre><p>在模板中标注出组件渲染的位置</p><h3 id="号的含义"><a href="#号的含义" class="headerlink" title="#号的含义"></a>#号的含义</h3><p>#号前表示的是发送给服务端的请求，要求返回html文件，而#号后表示的是发送给本地js的请求以寻求解决</p><h3 id="路由参数动态绑定"><a href="#路由参数动态绑定" class="headerlink" title="路由参数动态绑定"></a>路由参数动态绑定</h3><p>使用watch</p><pre class=" language-javascript"><code class="language-javascript">watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">'$route'</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span><span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//to当前路由，from上一个路由</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> to<span class="token punctuation">.</span>params<span class="token punctuation">.</span>id    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="路由的数据传递"><a href="#路由的数据传递" class="headerlink" title="路由的数据传递"></a>路由的数据传递</h3><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-link</span> <span class="token attr-name">:to</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ name: <span class="token punctuation">'</span>userEdit<span class="token punctuation">'</span>, params: { id: $route.params.id }, query: { locale: <span class="token punctuation">'</span>en<span class="token punctuation">'</span>, list: 2 } }<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-link</span><span class="token punctuation">></span></span></code></pre><p>传<code>query</code>参数可以达到地址栏出现<code>/?locale=en&amp;list=2</code><br>通过 <code>$route.query.键名</code> 来访问</p><h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p><code>router-view</code> 可以通过配置名字 <code>name</code> 来指定组件渲染的位置，增加了组件的复用性，比如分成 <code>header</code> <code>main</code> <code>hero</code> <code>footer</code> 来分别在一个视图中的不同位置上加载不同的组件 </p><h3 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h3><p>我们只需要加载我们需要的组件呈现给用户，而其他不需要第一时间加载的组件，可以使用 <code>webpack</code> 实现异步加载，只在需要的时候才会发出请求，请求加载另一个组件</p><p>routes.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> User <span class="token operator">=</span> resolve <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./components/user/User.vue'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./components/user/User.vue'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'GroupName'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//webpack 异步加载，通过组名，将要同时一起加载的组件打包加载</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;配置路由&quot;&gt;&lt;a href=&quot;#配置路由&quot; class=&quot;headerlink&quot; title=&quot;配置路由&quot;&gt;&lt;/a&gt;配置路由&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ npm install vue-router --save
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://tecknight.xyz/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://tecknight.xyz/tags/Vue/"/>
    
      <category term="router" scheme="http://tecknight.xyz/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>vuex快速入门</title>
    <link href="http://tecknight.xyz/2017/02/08/vuex%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://tecknight.xyz/2017/02/08/vuex快速入门/</id>
    <published>2017-02-08T00:26:19.000Z</published>
    <updated>2017-03-22T12:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本用途："><a href="#基本用途：" class="headerlink" title="基本用途："></a>基本用途：</h3><ul><li><p>将某些data变成组件间公用的状态，组件随时都可以进行访问和响应，解决了<code>props</code>传值的链式响应的代码冗余</p></li><li><p>给状态配以公用方法，将状态的变更及时响应并处理</p></li></ul><h3 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h3><a id="more"></a><p>/store/store.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span><span class="token punctuation">;</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">'vuex'</span><span class="token punctuation">;</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    state<span class="token punctuation">:</span> <span class="token punctuation">{</span>        sideBarOpened<span class="token punctuation">:</span> <span class="token boolean">false</span>        <span class="token comment" spellcheck="true">//放置公用状态</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>        changeState<span class="token punctuation">:</span> state <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//相当于vue实例中的methods,用于处理公用data</span>            <span class="token comment" spellcheck="true">//自vuex 面向组件的数据处理</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//写法与getters相类似</span>        <span class="token comment" spellcheck="true">//组件想要对于vuex 中的数据进行的处理</span>        <span class="token comment" spellcheck="true">//组件中采用this.$store.commit('方法名') 的方式调用，实现充分解耦</span>        <span class="token comment" spellcheck="true">//内部操作必须在此刻完成(同步)</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//使得mutations能够实现异步调用，实现例如延迟调用</span>        increment <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'突变方法名'</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">//payload应该是一个对象，可通过模板方法调用传入对象的方式将数据从组件传入vuex</span>          <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token function">asyncIncrement</span><span class="token punctuation">(</span><span class="token punctuation">{</span>commit<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>              <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                  <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>              <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//引入某一个state的以上集合的模块，会自动分别填充到上面，使得结构更加清晰</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>main.js</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> store <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./store/store'</span><span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>  store<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//注入根组件</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h4 id="访问vuex中的数据和方法"><a href="#访问vuex中的数据和方法" class="headerlink" title="访问vuex中的数据和方法"></a>访问vuex中的数据和方法</h4><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>数据名<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>方法名</code></pre><p>受影响组件局部定义计算属性响应变化数据</p><pre class=" language-javascript"><code class="language-javascript">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>     open <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>sideBarOpened     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>将 store 中的 getters/mutations 映射到局部(计算属性/方法)使用<code>mapGetters/mapMutations</code>辅助函数</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 使用对象展开运算符将 getters 混入 computed 对象中</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>        <span class="token comment" spellcheck="true">//映射 this.doneTodosCount 为 store.getters.doneTodosCount</span>      <span class="token string">'doneTodosCount'</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">//'getter名称',</span>      <span class="token comment" spellcheck="true">// 映射 this.doneCount 为 store.getters.doneTodosCount</span>          doneCount<span class="token punctuation">:</span> <span class="token string">'doneTodosCount'</span>      <span class="token comment" spellcheck="true">// 三个点表示将内部拿出生成键值对，这样使得组件本身的计算属性不受影响</span>      <span class="token comment" spellcheck="true">// 此语法依赖babel-preset-stage-2</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span></code></pre><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p>mutation 必须是同步函数 — devtool要保存快照，方便追踪状态变化</p><p>使用 v-model 绑定 vuex 计算属性的时候要设置get 和 set 才能双向绑定</p><pre class=" language-javascript"><code class="language-javascript">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    value<span class="token punctuation">:</span> <span class="token punctuation">{</span>        <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token keyword">set</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'updateValue'</span><span class="token punctuation">,</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本用途：&quot;&gt;&lt;a href=&quot;#基本用途：&quot; class=&quot;headerlink&quot; title=&quot;基本用途：&quot;&gt;&lt;/a&gt;基本用途：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;将某些data变成组件间公用的状态，组件随时都可以进行访问和响应，解决了&lt;code&gt;props&lt;/code&gt;传值的链式响应的代码冗余&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;给状态配以公用方法，将状态的变更及时响应并处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基本用法：&quot;&gt;&lt;a href=&quot;#基本用法：&quot; class=&quot;headerlink&quot; title=&quot;基本用法：&quot;&gt;&lt;/a&gt;基本用法：&lt;/h3&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://tecknight.xyz/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://tecknight.xyz/tags/Vue/"/>
    
      <category term="Vuex" scheme="http://tecknight.xyz/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>Laravel5 新手填坑指南</title>
    <link href="http://tecknight.xyz/2017/02/03/Laravel%20%E6%96%B0%E6%89%8B%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://tecknight.xyz/2017/02/03/Laravel 新手填坑指南/</id>
    <published>2017-02-03T05:26:19.000Z</published>
    <updated>2017-03-22T14:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器篇"><a href="#浏览器篇" class="headerlink" title="浏览器篇"></a>浏览器篇</h3><p>开发浏览器: Chorme（不用解释）</p><p>注意事项：</p><p>一定要先清缓存！清缓存！清缓存！ 重要的说三遍。</p><h3 id="环境配置篇"><a href="#环境配置篇" class="headerlink" title="环境配置篇"></a>环境配置篇</h3><p>开发环境：</p><p>Mac/Linux (少很多麻烦)</p><p>首选: Laravel Homestead (Mac上配置很轻松)</p><h3 id="正确开发习惯养成"><a href="#正确开发习惯养成" class="headerlink" title="正确开发习惯养成"></a>正确开发习惯养成</h3><p>千万注意每一个<code>function</code>的内容编写的时候先把<code>return</code>带上，返回的一般为数据或视图亦或是附上数据的视图，就算返回视图也要返回一个提示的局部视图闪现</p><h3 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h3><ol><li><p>涉及数据库的命令除了<code>artisan</code>新建<code>Model</code>文件以外最好都在虚拟机中执行，包括用<code>php artisan migrate</code></p></li><li><p><code>Model</code>中的代码改变之后，最好<code>migrate:refresh</code>一下，虽然还不理解Eloquent背后的机制，但是可以肯定的是，这样一种映射结构是牢固紧密的，如果Model中的函数被调用一次，那么,这种调用的映射关系会与数据库有持久性关联，如果<code>Model</code>的函数写错了，并且此函数被调用过了，请麻烦<code>refresh</code>一下</p></li><li><p>Eloquent 修改器在写的时候一定谨慎编写，尤其是用<code>bcrypt</code>加密密码存入数据库的时候</p></li></ol><h5 id="注意：如果不是修改原来的migration而是新建migration的话直接php-artisan-migrate即可"><a href="#注意：如果不是修改原来的migration而是新建migration的话直接php-artisan-migrate即可" class="headerlink" title="注意：如果不是修改原来的migration而是新建migration的话直接php artisan migrate即可"></a>注意：如果不是修改原来的migration而是新建migration的话直接<code>php artisan migrate</code>即可</h5><h3 id="目录结构篇"><a href="#目录结构篇" class="headerlink" title="目录结构篇"></a>目录结构篇</h3><ol><li>目录结构一旦更改，本身以及引用此类的命名空间也必须进行<code>全局替换</code>！！</li></ol><h3 id="命名空间篇"><a href="#命名空间篇" class="headerlink" title="命名空间篇"></a>命名空间篇</h3><ol><li>很多的<code>Class couldn&#39;t find</code>这类的错误都是没有写<code>use</code>进行引用就直接用了</li></ol><h3 id="路由篇"><a href="#路由篇" class="headerlink" title="路由篇"></a>路由篇</h3><ol><li>决定统一用REST过后最好用<code>resource</code>一次搞定</li></ol><h3 id="用户登录篇-Auth"><a href="#用户登录篇-Auth" class="headerlink" title="用户登录篇 Auth"></a>用户登录篇 Auth</h3><ol><li><p>引用的时候必须写成 </p><pre class=" language-php"><code class="language-php"> <span class="token keyword">use</span> <span class="token package">Auth</span><span class="token punctuation">;</span></code></pre></li><li><p>所有路由都要加上<code>-&gt;name(&#39;_name_&#39;)</code>，不然<code>&amp;#123;&amp;#123; route(&#39;name) &amp;#125;&amp;#125;</code>用不了</p></li></ol><h3 id="表单篇-RESTful"><a href="#表单篇-RESTful" class="headerlink" title="表单篇 RESTful"></a>表单篇 RESTful</h3><ol><li>用户的退出登录可以看成是提交一个DELETE表单</li><li>表单要加上<code>{&amp;#123;&amp;#123; csrf_field() &amp;#125;&amp;#125;</code>生成令牌token</li><li>需要伪装的协议必须加上<code>&amp;#123;&amp;#123; method_field(&#39;PATCH&#39;) &amp;#125;&amp;#125;</code>或<code>&amp;#123;&amp;#123; method_field(&#39;DELETE&#39;) &amp;#125;&amp;#125;</code></li></ol><h3 id="数据绑定视图"><a href="#数据绑定视图" class="headerlink" title="数据绑定视图"></a>数据绑定视图</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'users.edit'</span><span class="token punctuation">,</span> <span class="token function">compact</span><span class="token punctuation">(</span><span class="token string">'user'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用compact将user实例数据与视图进行绑定</span></code></pre><h4 id="注意compact的参数是字符串！！！"><a href="#注意compact的参数是字符串！！！" class="headerlink" title="注意compact的参数是字符串！！！"></a>注意compact的参数是字符串！！！</h4><p>用户数据与视图进行绑定后，便可以在视图上通过 <code>$user</code> 来访问用户对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器篇&quot;&gt;&lt;a href=&quot;#浏览器篇&quot; class=&quot;headerlink&quot; title=&quot;浏览器篇&quot;&gt;&lt;/a&gt;浏览器篇&lt;/h3&gt;&lt;p&gt;开发浏览器: Chorme（不用解释）&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;一定要先清缓存！清缓存！清缓存！ 重要的说三
      
    
    </summary>
    
      <category term="php" scheme="http://tecknight.xyz/categories/php/"/>
    
    
      <category term="php" scheme="http://tecknight.xyz/tags/php/"/>
    
      <category term="Laravel" scheme="http://tecknight.xyz/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel学习笔记</title>
    <link href="http://tecknight.xyz/2017/02/03/Laravel%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://tecknight.xyz/2017/02/03/Laravel 学习笔记/</id>
    <published>2017-02-03T05:26:19.000Z</published>
    <updated>2017-03-22T14:36:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ul><li>compact(‘变量1’,’变量2’)    </li></ul><p>类似于es6 的简写，会生成类似于<code>[&#39;name&#39; =&gt; $name]</code>的键值对</p><ul><li>dd(变量)</li></ul><p>程序运行到此处终止并输出变量的值</p><ul><li>Tinker 助手</li></ul><pre class=" language-bash"><code class="language-bash">php artisan tinker</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">>></span><span class="token operator">></span> App\Model::pluck<span class="token punctuation">(</span><span class="token string">'body'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//只取出此字段<span class="token operator">>></span><span class="token operator">></span> App\Model::where<span class="token punctuation">(</span><span class="token string">'id'</span>, <span class="token string">'>='</span>, 2<span class="token punctuation">)</span>-<span class="token operator">></span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span> App\Model::all<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">>></span><span class="token operator">></span> App\Model::first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><code>request()-&gt;all()</code></li><li><code>request([&#39;title&#39;, &#39;body&#39;])</code></li></ul><p>获取所有的post数据</p><p>只获取title和body</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>删除文件<br>删除完<code>migration</code>文件之后都要清除Composer中自动加载的记录，刷新自动加载记录</li></ul><pre class=" language-bash"><code class="language-bash">$ composer dump-autoload</code></pre><h3 id="技巧提点"><a href="#技巧提点" class="headerlink" title="技巧提点"></a>技巧提点</h3><ul><li>进一步封装查询语句</li></ul><p>Model.php</p><pre class=" language-php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">scopeIncompleted</span><span class="token punctuation">(</span><span class="token variable">$query</span><span class="token punctuation">,</span> <span class="token variable">$val</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token variable">$query</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">where</span><span class="token punctuation">(</span><span class="token string">'completed'</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将查询语句进行封装，调用时相当于静态方法</span>    <span class="token comment" spellcheck="true">//Model::incompleted();</span><span class="token punctuation">}</span></code></pre><ul><li>Model与路由的绑定</li></ul><pre class=" language-php"><code class="language-php">    Route<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/tasks/{thetask}'</span><span class="token punctuation">,</span> <span class="token string">'TasksController@show'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">show</span><span class="token punctuation">(</span>Task <span class="token variable">$thetask</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">view</span><span class="token punctuation">(</span><span class="token string">'tasks.show'</span><span class="token punctuation">,</span> <span class="token function">compact</span><span class="token punctuation">(</span><span class="token string">'thetask'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//路由中括号内的参数名必须与Controller中的接收参数的变量名字一致，类型是Model对象</span></code></pre><ul><li>命名规则</li></ul><p>controller =&gt; PostsController<br>Model =&gt; Post<br>migration =&gt; create_posts_table</p><ul><li>RESTFul</li></ul><pre class=" language-bash"><code class="language-bash">$ php artisan make:Controller TasksController -r</code></pre><p>创建一个resourceful controller</p><ul><li>文件路径更改</li></ul><p>与其相关的命名空间，包括文件本身的命名空间都需要进行修改！</p><ul><li>快速查看所有的路由</li></ul><pre class=" language-bash"><code class="language-bash">$ php artisan route:list</code></pre><ul><li>重定向返回至上一次请求尝试访问的页面</li></ul><pre class=" language-php"><code class="language-php"><span class="token keyword">return</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">intended</span><span class="token punctuation">(</span><span class="token function">route</span><span class="token punctuation">(</span><span class="token string">'users.show'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Auth<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="关于Blade"><a href="#关于Blade" class="headerlink" title="关于Blade"></a>关于Blade</h3><p><code>@yield(&#39;title&#39;, &#39;Sample&#39;)</code></p><p>声明title变量及其默认值</p><pre><code>@yield(&#39;content&#39;)// content区域@extends(&#39;layouts.default&#39;)@section(&#39;content&#39;)// 内容将会被插入布局模板中@stop</code></pre><p><code>@yield</code> 用于定义</p><p><code>@section</code> 用于插入值</p><p><code>@include(&#39;shared.user_info&#39;, [&#39;user&#39; =&gt; $user])</code></p><p>给局部视图传参数</p><p><code>old(&#39;name名称&#39;)</code></p><p>辅助函数显示旧的输入数据</p><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><ul><li>每一个Model内部都有三个属性</li></ul><p><code>$table</code> <code>$fillable</code> <code>$hidden</code></p><p>指明交互的数据表名称，能进行更新的字段，JSON形式显示时隐藏的字段</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>每一个controller中都有一个<code>validator</code>，可以用来验证字段</li></ul><h3 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h3><ol><li>创建会话实例</li></ol><p><code>session()-&gt;flash(&#39;success&#39;, &#39;欢迎，您将在这里开启一段新的旅程~&#39;);</code></p><p>flash方法使得会话缓存只在下一次请求中有效，第一个参数是键名，第二个参数是键值</p><ol><li>访问会话实例</li></ol><p><code>session()-&gt;get(&#39;success&#39;)</code></p><h3 id="Auth-认证系统"><a href="#Auth-认证系统" class="headerlink" title="Auth 认证系统"></a>Auth 认证系统</h3><p><code>Auth::attempt()</code>尝试登陆</p><p><code>Auth::user()</code>当前登录实例</p><p><code>Auth::check()</code> 是否已经登录</p><p>API:</p><p><code>bool attempt(array $credentials = array(), bool $remember = false)</code></p><p>第二个参数用来开发记住密码</p><h3 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h3><ul><li>在用户控制器构造方法中应用中间件</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">__construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">middleware</span><span class="token punctuation">(</span><span class="token string">'auth'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>                        <span class="token string">'only'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">'edit'</span><span class="token punctuation">,</span> <span class="token string">'update'</span><span class="token punctuation">]</span>        <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li><code>Authenticate.php</code>中进行重定向</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token variable">$request</span><span class="token punctuation">,</span> Closure <span class="token variable">$next</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">auth</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">guest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$request</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">response</span><span class="token punctuation">(</span><span class="token string">'Unauthorized.'</span><span class="token punctuation">,</span> <span class="token number">401</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">redirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">guest</span><span class="token punctuation">(</span><span class="token string">'login'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token variable">$next</span><span class="token punctuation">(</span><span class="token variable">$request</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="授权策略"><a href="#授权策略" class="headerlink" title="授权策略"></a>授权策略</h3><p>已登录的用户之间的权限控制</p><ul><li>创建Policy文件并创建用户比对方法</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span>User <span class="token variable">$currentUser</span><span class="token punctuation">,</span> User <span class="token variable">$user</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$currentUser</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span> <span class="token operator">===</span> <span class="token variable">$user</span><span class="token operator">-</span><span class="token operator">></span><span class="token property">id</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>在<code>AuthServiceProvider</code>中进行授权策略的配置，将用户模型指定授权策略</li></ul><pre class=" language-php"><code class="language-php">    <span class="token keyword">protected</span> <span class="token variable">$policies</span> <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">'App\Model'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'App\Policies\ModelPolicy'</span><span class="token punctuation">,</span>        User<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span> <span class="token operator">=</span><span class="token operator">></span> UserPolicy<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span>        <span class="token comment" spellcheck="true">//全路径匹配</span>    <span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><ul><li>将查询时返回的User实例发送给授权策略进行比较</li></ul><pre class=" language-php"><code class="language-php">   <span class="token variable">$user</span> <span class="token operator">=</span> User<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">findOrFail</span><span class="token punctuation">(</span><span class="token variable">$id</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">authorize</span><span class="token punctuation">(</span><span class="token string">'update'</span><span class="token punctuation">,</span> <span class="token variable">$user</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用函数：&quot;&gt;&lt;a href=&quot;#常用函数：&quot; class=&quot;headerlink&quot; title=&quot;常用函数：&quot;&gt;&lt;/a&gt;常用函数：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;compact(‘变量1’,’变量2’)    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似于es6 的简写，会生
      
    
    </summary>
    
      <category term="PHP" scheme="http://tecknight.xyz/categories/PHP/"/>
    
    
      <category term="php" scheme="http://tecknight.xyz/tags/php/"/>
    
      <category term="Laravel" scheme="http://tecknight.xyz/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 5 常用帮助函数</title>
    <link href="http://tecknight.xyz/2017/02/03/Laravel%205%20%E5%B8%B8%E7%94%A8%E5%B8%AE%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
    <id>http://tecknight.xyz/2017/02/03/Laravel 5 常用帮助函数/</id>
    <published>2017-02-03T05:26:19.000Z</published>
    <updated>2017-03-22T14:44:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-app-用于快速生成对应命名空间下的类的实例"><a href="#1-app-用于快速生成对应命名空间下的类的实例" class="headerlink" title="1.app() 用于快速生成对应命名空间下的类的实例"></a>1.app() 用于快速生成对应命名空间下的类的实例</h3><pre class=" language-php"><code class="language-php"><span class="token variable">$faker</span> <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span>Faker\<span class="token package">Generator</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成了一个Faker的生成器实例</span></code></pre><h3 id="2-str-random-用于快速生成限定范围内的随机字符串"><a href="#2-str-random-用于快速生成限定范围内的随机字符串" class="headerlink" title="2.str_random() 用于快速生成限定范围内的随机字符串"></a>2.str_random() 用于快速生成限定范围内的随机字符串</h3><pre class=" language-php"><code class="language-php"><span class="token variable">$password</span> <span class="token operator">=</span> <span class="token function">str_random</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//生成10位随机密码</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-app-用于快速生成对应命名空间下的类的实例&quot;&gt;&lt;a href=&quot;#1-app-用于快速生成对应命名空间下的类的实例&quot; class=&quot;headerlink&quot; title=&quot;1.app() 用于快速生成对应命名空间下的类的实例&quot;&gt;&lt;/a&gt;1.app() 用于快速
      
    
    </summary>
    
      <category term="php" scheme="http://tecknight.xyz/categories/php/"/>
    
    
      <category term="php" scheme="http://tecknight.xyz/tags/php/"/>
    
      <category term="Laravel" scheme="http://tecknight.xyz/tags/Laravel/"/>
    
  </entry>
  
</feed>
